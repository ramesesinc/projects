import com.rameses.annotations.*;
import com.rameses.util.*;
import java.rmi.server.*;
import com.rameses.common.*
import com.rameses.services.extended.*;
import java.util.*;
import com.rameses.rules.common.*;

class RuleExecutorService {

	@Resource("RuleService")
	def ruleSvc;

	@ActiveDB("rule")
	def ruleDB;
		
	private static Map metaClasses = Collections.synchronizedMap(new HashMap());


	private def getClassInstance( String ruleset, String actionName, String actionClassname) {
		if( !metaClasses.containsKey(ruleset)  ) metaClasses.put(ruleset, [:] );
		def rsMap = metaClasses.get(ruleset);
		if( !rsMap.containsKey(actionName) ) {
			try {
				rsMap.put( actionName, getClass().getClassLoader().loadClass(actionClassname).newInstance() );
			}
			catch(Exception ex) {
				println "error loading action class " + actionName + " ->" + ex.message;
			}
		}
		return rsMap.get(actionName);
	}

	@ProxyMethod	
	public def execute( String ruleset, def facts, def actions, def handler )	{
		def ctx = null;
		try {
			ctx = new RuleExecutionContext(facts);

			def ruleAction = actions;

			if(ruleAction==null) {
				ruleAction = new RuleAction();
				def actionList = ruleDB.getRuleActionsForLoading([ruleset: ruleset]);
				actionList.each {
						def obj = getClassInstance(ruleset, it.actionname, it.actionclass );
						ruleAction.addCommand( it.actionname, obj ); 
				}
			}

			def grps = ruleDB.getRulegroups( [ruleset: ruleset] );
			for( g in grps ) {
				ruleSvc.execute( ruleset, facts, ruleAction, g.name );
				if(handler) handler( g.name );
			}
			return ctx.result;
		}
		catch(BreakException be) {
			return ctx.result;
		}
		catch(e) {
			throw e;
		}
		finally {
			ctx.close();
		}
	}


}
