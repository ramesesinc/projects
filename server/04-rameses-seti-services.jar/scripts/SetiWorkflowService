import com.rameses.annotations.*;
import java.rmi.server.UID;

class SetiWorkflowService {
	
	@DataContext("sys_wf")
	def wf;

    @DataContext("sys_wf_node")
    def wfnode;

    @DataContext("sys_wf_transition")
    def wftransition;

	@DataContext(dynamic=true)
	def taskEm;

	@Service("DateService")
	def dateSvc;

    @Env
    def env;


    def findNode( String processname, String state ) {
        //find the next node and transitions
        def node = wfnode.find( [processname:processname, name: state] ).first();
        if(!node) throw new Exception("Node not found ->"+processname + "." + state + " " +taskid);
        node.transitions = wftransition.find([processname:processname, parentid: state] ).sort("idx").list();
        node.transitions.each {
            if(it.properties) it.properties = wf.serializer.read(it.properties); 
        }
        return node;
    }

    def addTask( String processname, String refid, String state, def assignee, def msg, def props ) {
        def tsk = [:];
        tsk.taskid = "TSK"+new UID();
        tsk.refid = refid;
        tsk.state = state;
        tsk.startdate = dateSvc.getServerDate();
        tsk.assignee = assignee;
        tsk.message = msg;
        if( props ) {
            tsk.putAll( props );
        }

        def tskDb = taskEm.lookup( processname.trim() + "_task" );
        tskDb.create(tsk);
        return tsk;
    }

    @ProxyMethod
    public def start(def o) {
    	if(!o.processname) throw new Exception("processname is required in start");
    	if(!o.refid) throw new Exception("refid is required in start");
    	def tlist = wftransition.find( [processname: o.processname, name:'start'] ).list();

        //check first if this particular refid already exists.
        def tskDb = taskEm.lookup( o.processname.trim() + "_task" );
        def m = tskDb.find([refid: o.refid]).first();
        if(m) throw new Exception("A task has already been started for this transaction");

        def tsk = addTask( o.processname, o.refid, tlist[0].to, o.assignee, null, null );
        return findOpenTask( [processname:o.processname, taskid: tsk.taskid] ); 
    }

    @ProxyMethod
    public void checkBeforeSignal( def o ) {
        if(!o.processname) throw new Exception("processname is required in checkBeforeSignal");
        if(!o.taskid) throw new Exception("taskid is required in checkBeforeSignal");

        //try to check if there are open subtasks
        println "checking sub task 1";
        def subtaskDb = null;
        try {
            subtaskDb = taskEm.lookup( o.processname.trim() + "_subtask" );
        } catch(Exception ign) {;} 
        if(subtaskDb !=null) {
            println "checking sub task 2";
            def subList = subtaskDb.find( [taskid: o.taskid] ).list();
            if( subList.size>0) {
                throw new Exception("There are still unfinished sub tasks. Please have these completed first");
            }
        }
    }

	@ProxyMethod
    public def signal(def o) {
    	if(!o.processname) throw new Exception("processname is required in signal");
    	if(!o.refid && !o.taskid) throw new Exception("refid or taskid is required in signal");

        def prevTask = findOpenTask(o);

        //close the previous task and add the next task
        def histDb = taskEm.lookup( o.processname.trim() + "_task_history" );
        def tskDb = taskEm.lookup( o.processname.trim() + "_task" );

        //actor should be the one who logged in unless specified
        if(o.actor){
            prevTask.actor = o.actor;    
        }
        else {
            prevTask.actor = [objid: env.USERID , name: env.USER];
        }
        prevTask.enddate = dateSvc.getServerDate();
        histDb.create( prevTask );
        tskDb.find([taskid: prevTask.taskid]).delete();

        /*****************************************************************************************
        * search transition based on the action. If not specified fire the first transition found
        ******************************************************************************************/
        def transition = null;
        if( o.action ) {
            transition = prevTask.transitions.find{it.action==o.action}; 
        }
        else if(prevTask.transitions.size()==1) {
            transition = prevTask.transitions[0];
        }
        else {
            //check eval condition
        }
        if(!transition)
            throw new Exception("Transition not found for signal");

        /***************************************************************************
        * determine assignee. If assignee is provided in parameter use that 
        * else if action starts with word return e.g. return_assessment. The state
        * in this case is assessment so find the last task that has this actor  
        ****************************************************************************/
        def assignee = o.assignee;
        if( !assignee ) {
            if( o.action && o.action.startsWith("return") ) {
                String returnState = transition.to;
                int ip = o.action.indexOf("_");
                if(ip>0) returnState = o.action.substring( ip + 1);
                def v = histDb.find( [refid: prevTask.refid, state:returnState]).sort("startdate", "DESC").limit(1).first();
                assignee = v.assignee;
            }    
        }

        if(transition.to == 'end') {
            def endTask = [:];
            endTask.refid = prevTask.refid;
            endTask.state = 'end';        
            return endTask;
        }
        else {
            def tsk = addTask( o.processname, prevTask.refid, transition.to, assignee, o.message, o.properties );
            return findOpenTask( [processname:o.processname, taskid: tsk.taskid] );      
        }
    }

    /************************************************************************************
    * Find open task can be found in two ways. By specific taskid or by reference
    * By reference: 
    *     if only 1 task found return immediately
    *     if state provided, return only task that matches state
    *     if actor provided, return only task for that actor
    *************************************************************************************/
    @ProxyMethod
    public def findOpenTask(def o) {
        if(!o.processname) throw new Exception("processname is required in findTask");
        if(!o.taskid && !o.refid) 
            throw new Exception("findOpenTask requires taskid or refid");

        def histDb = taskEm.lookup( o.processname.trim() + "_task_history" );
        def tskDb = taskEm.lookup( o.processname.trim() + "_task" ); 

        def task = null;
        if(o.taskid) {
            task = tskDb.find( [taskid: o.taskid]  ).first();
            if(!task) {
                //check if task found in the history 
                def hist = histDb.find( [taskid: o.taskid] ).first();
                if(hist)
                   throw new Exception('Task is already closed. Taskid is ' + o.taskid);
                else       
                    throw new Exception('Task not found. Taskid is ' + o.taskid);
            }
        }
        else {

            //find the open tasks that matches the state or actor
            def tskList = tskDb.find( [refid: o.refid ]).list();
            if( tskList.size() == 0 ) {
                def hist = histDb.find( [refid: o.refid] ).first();
                if(hist)
                    throw new Exception("All tasks have been completed");
                else    
                    throw new Exception("No tasks found for this refid. Specify taskid instead");
            }
            else if( tskList.size() == 1) {
                task = tskList[0];
            }
            else if( o.state !=null ) {
                //filter by state if provided
                task = tskList.find{ it.state == o.state };
            }
            else {
                //filter by assignee if provided
                def assigneeId = env.USERID;
                if( o.assignee !=null ) assigneeId = o.assignee.objid; 
                def assigneeList = tskList.findAll{ it.assignee?.objid == assigneeId }; 
                if(assigneeList.size()>0) {
                    task = assigneeList[0];
                }
            }
        }

        def node = findNode( o.processname, task.state );
        task.state = node.name;        
        task.title = node.title;
        task.state = node.name;
        task.message = task.message;
        task.domain = node.domain;
        task.role = node.role;
        task.transitions = [];
        for( t in node.transitions ) {
            def g = [:];
            if(t.properties) g.putAll( t.properties );
            g.to = t.to;
            g.action = t.action; 
            if(!g.caption) g.caption = t.action;
            if(!g.caption) g.caption = t.to;
            g.permission = t.permission;
            task.transitions << g;
        }
        return task;
    }

    @ProxyMethod
    public def getHistoryList(def o) {
        if(!o.processname) 
            throw new Exception("processname is required in findTask");
        if(!o.refid) 
            throw new Exception("findOpenTask requires refid");

        def histDb = taskEm.lookup( o.processname.trim() + "_task_history" );
        def list = histDb.find([refid:o.refid]).sort("startdate").list();
        list.each {
            it.timediff = '2 days';
        }
        return list;
    }

    @ProxyMethod
    public def getOpenSubtaskList(def o) {
        if(!o.processname) 
            throw new Exception("processname is required in findTask");
        if(!o.taskid) 
            throw new Exception("getOpenSubtaskList requires taskid");
        try {
            def subtaskDb = taskEm.lookup( o.processname.trim() + "_subtask" );
            def list = subtaskDb.find([taskid:o.taskid]).sort("startdate").list();
            list.each {
                it.lapsetime = '3 days';
            }
            return list;
        }
        catch(e) {
            return [];
        }
    }

    /*******************************************************************************************
    * retrieve assignees for the task
    *******************************************************************************************/
    @ProxyMethod
    public def getAssigneeList(def o) {
        return [];
    }
}