import com.rameses.annotations.*;
import java.rmi.server.*;
import com.rameses.rules.common.*;
import com.rameses.util.*;
import com.rameses.services.extended.*;
import rptis.landtax.facts.*;
import rptis.landtax.actions.*;


public class RPTBillingRuleUtilService
{
	@ActiveDB('rptbill')
	def em 

	@Service('DateService')
	def dtSvc

	@Service('LGUService')
	def lguSvc 

	@Service('RPTUtil')
	def util

	@Service('NumberService')
	def numSvc

	@DataContext('landtax_lgu_account_mapping')
	def em_landtax_lgu_account_mapping

	def RULESET 			= 'rptbilling'
	def FACT_PACKAGE 		= 'rptbilling.'
	

	@ProxyMethod 
	public def buildRequest(bill){
		bill.billdate = dtSvc.parse('yyyy-MM-dd',bill.billdate) 
		bill._pdate = dtSvc.parseDate(bill.billdate, null)
		bill.items.each{
			it._pdate = bill._pdate
			it.taxdifference = (it.taxdifference == 1)
		}

		def facts = []
		facts << new CurrentDate(bill.billdate)
		facts << new EffectiveDate(bill.billdate)
		createRPTLedgerFact(bill, facts)
		def actions = buildActions(bill, facts)
		bill.remove('items')
		return [facts:facts, actions:actions]
	}


	void createRPTLedgerFact(bill, facts){
		def rptledger = bill.rptledger

		def brgy = lguSvc.lookupBarangayById(rptledger.barangayid)
		if (brgy.munidistrict.orgclass.equalsIgnoreCase('municipality')){
			rptledger.lguid = brgy.munidistrict.objid 
		}
		else{
			rptledger.lguid = brgy.provcity.objid 
		}

		rptledger.undercompromise = determineUnderCompromise(rptledger)
		rptledger.firstqtrpaidontime = determineFirstQtrPaidOntime(rptledger)
		rptledger.missedpayment = determineMissedPayment(rptledger)

		def ledgerfact = new RPTLedgerFact(rptledger)
		facts << ledgerfact 

		bill.items.eachWithIndex{ it, idx ->
			it.fullypaid = checkIfFullyPaid(bill, ledgerfact, it)
			it.qtrlypaymentavailed = checkIfQtrlyPaymentAvailed(bill, ledgerfact, it)
			facts << createLedgerItemFact(ledgerfact, it, idx)
		}
		bill.incentives.each{
			facts << new RPTIncentive(ledgerfact, it)
		}
	}


	def determineUnderCompromise(rptledger){
		def compromise = em.findCompromiseByLedger(rptledger)
		if (compromise && compromise.state.matches('FORPAYMENT|FORAPPROVAL|APPROVED'))
			return true
		return false
	}

	def determineFirstQtrPaidOntime(rptledger){
		def pdate = dtSvc.parseCurrentDate()
		if (rptledger.lastyearpaid == pdate.year - 1 && rptledger.lastqtrpaid == 4 )
			return true;

		def curryearpmt = em.findLatestPayment([objid:rptledger.objid, cy:pdate.year])
		if (! curryearpmt.receiptdate)
			return false;

		curryearpmt.receiptdate = dtSvc.parse('yyyy-MM-dd', curryearpmt.receiptdate)
		def firstqtrenddate = dtSvc.getQtrEndDate(1, pdate.year)
		return curryearpmt.receiptdate <= firstqtrenddate
	}

	def determineMissedPayment(rptledger){
		def pdate = dtSvc.parseCurrentDate()

		//1st qtr, no missed payment 
		if (pdate.qtr == 1) 
			return false 


		def payments = em.getCurrentYearCredits([objid:rptledger.objid, cy:pdate.year])

		if (!payments && pdate.qtr > 1) {
			//no payments since 1st qtr 
			return true 
		}

		if (payments.toqtr.max()+1 < pdate.qtr){
			//miss payment previous qtr
			return true 
		}

		def missedpayment = false 
		payments.each{pmt -> 
			pmt.fromqtr.upto(pmt.toqtr){qtr->
				def qtrenddate = dtSvc.getQtrEndDate((Integer)qtr, pdate.year) + 1 
				if (pmt.receiptdate > qtrenddate){
					missedpayment = true 
				}
			}
		}
		return missedpayment
	}


	def checkIfFullyPaid(bill, ledgerfact, item){
		if (item.year < bill.billtoyear)
			return true
		if (item.year >= bill.billtoyear && bill.billtoqtr == 4)
			return true
		return false
	}

	def checkIfQtrlyPaymentAvailed(bill, ledgerfact, item){
		if (item.year == ledgerfact.lastyearpaid)
			return true;
		if (item.year < bill.billtoyear)
			return false
		if (item.year == bill.billtoyear && bill.billtoqtr != 4)
			return true 
		return false
	}


	def createLedgerItemFact( ledgerfact, item, idx ) {
		item.numberofmonthsfromqtr = calculateNoOfMonthsFromQtr(item._pdate, item.year, item.qtr)
		item.numberofmonthsfromjan = calculateNoOfMonthsFromJan(item._pdate, item.year, item.qtr)
		item.backtax = determineBacktax(item)
		return new RPTLedgerItemFact(ledgerfact, item, idx)
	}

	int calculateNoOfMonthsFromQtr(pdate, year, qtr) {
		if (qtr == null || qtr == 0) qtr = 1 
		int currYear = pdate.year
		int currMonth = pdate.month
		qtr = ( qtr == 0 ? 1 : qtr )
		if(year < currYear) {
			return ((currYear - year) * 12 - (3 * (qtr-1))) + currMonth 
		}
		else {
			int nm = currMonth - (3 * (qtr-1))
			return nm < 0 ? 0 : nm
		}
	}
	
	
	int calculateNoOfMonthsFromJan(pdate, year, qtr) {
		int currYear = pdate.year
		int currMonth = pdate.month
		int nmon = 0;
		if(year < currYear) {
			nmon = ( currYear - year ) * 12 + currMonth
		}
		else {
			nmon = currMonth
		}
		return nmon 
	}	

	def determineBacktax( item ) {
		if (util.isTrue(item.backtax)) return true

		if (item.effectivityyear == null)
			item.effectivityyear = item.effectiveyear 

		def txntype_objid = item.txntype?.objid; 
		return ( txntype_objid.toString().equalsIgnoreCase('ND') && item.year == item.effectivityyear ); 
	}





	/*====================================================================
	* BUILD ACTIONS
	====================================================================*/

	@ProxyMethod
	public def buildActions(bill, facts){
		def actions = new RuleAction();
		actions.addCommand('split-by-qtr', new SplitByQtr(facts:facts, NS:numSvc))
		actions.addCommand('calc-basic', new CalcBasic(numSvc:numSvc))
		actions.addCommand('calc-sef', new CalcSEF(numSvc:numSvc))
		actions.addCommand('calc-firecode', new CalcFireCode(numSvc:numSvc))
		actions.addCommand('calc-idleland', new CalcIdleLand(numSvc:numSvc))
		actions.addCommand('calc-sh', new CalcSh(numSvc:numSvc))
		actions.addCommand('apply-incentive', new ApplyIncentive(numSvc:numSvc))

		actions.addCommand('create-tax-summary', new CreateTaxSummary(numSvc:numSvc, facts:facts))
		actions.addCommand('add-cityshare-acct', new AddShareInfo(numSvc:numSvc, facts:facts, taxes:bill.taxes, lgutype:'city', getRevenueAccount:getRevenueAccount))
		actions.addCommand('add-provshare-acct', new AddShareInfo(numSvc:numSvc, facts:facts, taxes:bill.taxes, lgutype:'province', getRevenueAccount:getRevenueAccount))
		actions.addCommand('add-munishare-acct', new AddShareInfo(numSvc:numSvc, facts:facts, taxes:bill.taxes, lgutype:'municipality', getRevenueAccount:getRevenueAccount))
		actions.addCommand('add-brgyshare-acct', new AddShareInfo(numSvc:numSvc, facts:facts, taxes:bill.taxes, lgutype:'barangay', getRevenueAccount:getRevenueAccount))
		actions.addCommand('add-firecode-acct', new AddFireCodeAccount(numSvc:numSvc, items:bill.items, taxes:bill.taxes))
		return actions 
	}



	def createVariableFact = { facts, rptledger, amount ->
		def var = ruleSvc.createFact(RULESET, FACT_PACKAGE+'VariableInfoFact')
		var.rptledger = rptledger
		var.amount = amount 
		facts << var
		return var
	}
	
	def getRevenueAccount = {params ->
		def acct = params.acct 
		def p = [:]
		p.revtype = params.sharetype.replaceAll('disc', '')
		p.revperiod = params.taxsummary.revperiod 
		if ('barangay'.equalsIgnoreCase(params.lgutype)){
			p.lgu_objid = params.taxsummary.rptledger.barangayid
			acct = em_landtax_lgu_account_mapping.select('item.objid,item.title').find(p).first() 
		}
		else if (params.lgutype.toLowerCase().matches('municipality|city')){
			p.lgu_objid = params.taxsummary.rptledger.lguid
			acct = em_landtax_lgu_account_mapping.select('item.objid,item.title').find(p).first() 
		}
		else if ('province'.equalsIgnoreCase(params.lgutype)){
			p.lgu_orgclass = 'PROVINCE'
			acct = em_landtax_lgu_account_mapping.select('item.objid,item.title').find(p).first() 	
		}

		if (acct){
			return [key:acct.item.objid, value:acct.item.title]
		}
		throw new Exception('Account mapping does not exist for ' + p.revtype + ' ' + p.revperiod + '.')
	}


	@ProxyMethod
	public def buildShareRequest(bill, ledger) {
		def xbill = bill 
		xbill.taxes = []
		def facts = []

		def billdate = dtSvc.parse('yyyy-MM-dd', xbill.billdate) 
    	facts << new CurrentDate(billdate)
    	facts << new EffectiveDate(billdate)

		def ledgerfacts = [:]
		def ledgerfact = new RPTLedgerFact(ledger)
		facts << ledgerfact

    	ledger.items.eachWithIndex{it, idx ->
    		facts << new RPTLedgerItemFact(ledgerfact, it, idx)
    	}
		def actions = buildActions(xbill, facts)
		return [facts:facts, actions:actions, bill:xbill]
	}
}
