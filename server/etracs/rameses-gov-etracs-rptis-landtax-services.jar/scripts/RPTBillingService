import com.rameses.annotations.*;
import java.rmi.server.*;
import com.rameses.rules.common.*;
import com.rameses.util.*;
import com.rameses.services.extended.*;
import rptis.landtax.facts.*;
import rptis.landtax.actions.*;


public class RPTBillingService
{
	@ActiveDB('rptbill')
	def em 

	@ActiveDB("rule")
	def ruleDB;

	@Env
	def env

	@Service('RPTUtil')
	def util

	@Service('Var')
	def var 

	@Service('DateService')
	def dtSvc 

	@Service('NumberService')
	def numSvc

	@Service('SequenceService')
	def seqSvc

	@Service('RPTLedgerService')
	def ledgerSvc 

	@Resource("RuleService")
	def ruleSvc;

	@DataContext('faas_restriction')
	def em_faas_restriction;

	@DataContext('itemaccount')
	def em_itemaccount;

	@DataContext('rptbill')
	def em_rptbill;

	@DataContext('rptbill_ledger')
	def em_rptbill_ledger;

	@DataContext('rptledger_item')
	def em_rptledger_item;

	@DataContext('rptledger_item_qtrly')
	def em_rptledger_item_qtrly;

	@Service('RPTBillingRuleUtilService')
	def ruleUtilSvc 


	def RULESET 			= 'rptbilling'
	def FACT_PACKAGE 		= 'rptbilling.'
	def MAX_ADVANCE_YEARS 	= 3 
	
	def SCHEMA_BILL_LEDGER 	= 'rptbill_ledger'
	def SCHEMA_BILL_ITEM 	= 'rptbill_item'
	def SCHEMA_BILL_ACCT 	= 'rptbill_account'

	def BARCODE_PREFIX 		= '56001:'


	@ProxyMethod
	public def initBill(ledgerid){
		def pdate = dtSvc.parseCurrentDate()
		def objid = 'RB' + new java.rmi.server.UID()
		return [
			objid 				: objid,
			billid 				: objid,
			billtoyear 			: pdate.year,
			billtoqtr			: 4,
			advancebill			: false,
			fullpayment    		: true,
            qtrlypaymentavailed : false, 
            advancepayment      : false,
            currentdate 		: pdate.date,
            cy 					: pdate.year,
            rptledgerid 		: ledgerid,
            barcode 			: generateBarcode()
		]
	}


	@ProxyMethod
	public def generateBill( bill ) {
		util.required('Ledger to bill', bill.rptledgerid )

		bill.rptledger = em.findOpenLedgerById(bill)
        if (!bill.rptledger) throw new Exception('Ledger is fully paid or is exempted.')

		validateAndSetBillParam(bill)

        if (bill.rptledger.recalcbill == 1 || bill.forcerecalcbill == 1){
        	println 'Recalculating ledger -> ' + bill.rptledger.tdno 
        	def cy = dtSvc.serverYear 
	        def endyear = ( bill.billtoyear < cy ? cy : bill.billtoyear)
	        ledgerSvc.postLedgerItemsUptoYear(bill.rptledger, endyear)
	        executeRules(bill)
        	updateNextBillDate(bill)
        }
    	saveBill(bill)
		return bill
	}

	void executeRules(bill){
		calculateTaxDues(bill)
		calculatePenaltyDiscount(bill)
	}


	void calculateTaxDues(bill){
		bill.incentives = em.getIncentivesByLedgerId(bill)
		bill.items = em.getItemsForTaxComputation(bill)
		def request = ruleUtilSvc.buildRequest(bill)
		def grps = ['TAX','AFTER_TAX','IDLE_LAND','AFTER_IDLE_LAND','SUMMARY']
		grps.each{g ->
			ruleSvc.execute( RULESET, request.facts, request.actions, g);
		}
		saveBillItems(bill, request)
	}

	void calculatePenaltyDiscount(bill){
		bill.items = em.getItemsForPenaltyDiscount(bill)
		def request = ruleUtilSvc.buildRequest(bill)
		def grps = ['INIT','PENALTY','AFTER_PENALTY','DISCOUNT','AFTER_DISCOUNT','SUMMARY']
		grps.each{g ->
			ruleSvc.execute( RULESET, request.facts, request.actions, g);
		}
		saveBillItems(bill, request)
	}

	void saveBillItems(bill, request){
		bill.items = []
		def itemfacts = request.facts.findAll{it instanceof RPTLedgerItemFact}
		def items = []
		itemfacts.each{
			it.recalcQtrlyItems()
			items << it.toMap()
		}

		if (util.toBoolean(bill._commit, true) == true){
			items.each{
				if (it.parentid){
					em_rptledger_item_qtrly.find([objid:it.objid]).update(it)
					bill.items << it 
				}
				else {
					em_rptledger_item.find([objid:it.objid]).update(it)
					it.qtrlyitems.each{qi->
						em_rptledger_item_qtrly.find([objid:qi.objid]).update(qi)
						bill.items << qi 
					}	
					if (it.qtr != 1){
						//qtrly items has payment or is less than 4 qtrs 
						//update item totals only
						updateLedgerItemTotals(it.objid, it.qtrlyitems, false)
					}
				}
			}
			//for qtrlyitems, update rptledgeritem info 
			def m = items.findAll{it.parentid != null}.groupBy{it.parentid}
			m.each{k,v ->
				updateLedgerItemTotals(k, v, true)
			}
		}
	}

	void updateLedgerItemTotals(k, list, qtrly){
		def m = [:]
		m.objid = k 
		m.revperiod = list.first().revperiod
		m.basic = list.basic.sum()
		m.basicint = list.basicint.sum()
		m.basicdisc = list.basicdisc.sum()
		m.basicidle = list.basicidle.sum()
		m.basicidleint = list.basicidleint.sum()
		m.basicidledisc = list.basicidledisc.sum()
		m.sef = list.sef.sum()
		m.sefint = list.sefint.sum()
		m.sefdisc = list.sefdisc.sum()
		m.firecode = list.firecode.sum()
		m.sh = list.sh.sum()
		m.shint = list.shint.sum()
		m.shdisc = list.shdisc.sum()
		m.qtrly = qtrly 
		em_rptledger_item.find([objid:m.objid]).update(m)
	}

	void updateNextBillDate(bill){
		bill.nextbilldate = getExpiryDate(bill)
	    em.updateLedgerNextBillDate(bill)
	}

	def getExpiryDate(bill) { 
		def dt = dtSvc.parseDate(bill.billdate,null);

		//check in database if there is qtr deadline overrides
		def qtr_deadline = em.findExpiry([qtr:dt.qtr, year:dt.year, date:dt.date])
		
		//check discount, interest overrides
		def expirydate = null;
		def expirytype = null;

		if( ! qtr_deadline ) {
			qtr_deadline = [
				expirydate : dtSvc.getQtrEndDate(dt.qtr, dt.year),
				expirytype : 'QTRDUEDATE',
			]
		}

		qtr_deadline.expirydate = dtSvc.add(qtr_deadline.expirydate, '1d');
		expirytype = qtr_deadline.expirytype;

		//check discount first
		if(expirytype?.equalsIgnoreCase("DISCOUNT")) {
			return qtr_deadline.expirydate;
		}

		//if billtoyear > server year (advance payment) 
		// expiry is end of jan next year
		if (bill.billtoyear > dt.year){
			return dtSvc.parse('yyyy-MM-dd',  (dt.year + 1) + '-01-01')
		}

		//if there are arrears, expiry is first day of next month
		if (bill.rptledger.lastyearpaid <= dt.year){
			return dtSvc.add(dtSvc.getMonthEndDate(dt.date), '1d')
		}


		//check for interest overrides
		if( expirytype?.equalsIgnoreCase("INTEREST")) {
			return qtr_deadline.expirydate;
		}
		
		if( qtr_deadline ) {
			return qtr_deadline.expirydate;
		}	
		else {
			return dtSvc.add(dtSvc.getMonthEndDate(dt.date), '1d')
		} 
	}

	void saveBill(bill){
		if (!bill.barcode) 
			bill.barcode = generateBarcode()

		bill.postedby = (env.FULLNAME ? env.FULLNAME : 'system')
		bill.postedbytitle = (env.JOBTITLE ? env.JOBTITLE  : 'system')
		bill.dtposted = dtSvc.serverDate

		if (bill.rptledger.taxpayer)
			bill.taxpayer = bill.rptledger.taxpayer 

		bill.rptledger.billid = bill.objid 
		bill.rptledger.rptledgerid = bill.rptledger.objid 
		bill.rptledger.updateflag = bill.rptledger.updateflag 

		bill.expirydate = getExpiryDate(bill)
	    bill.validuntil = dtSvc.add(bill.expirydate, '-1d')
		em.save(bill)
		em.save(bill.rptledger, SCHEMA_BILL_LEDGER)
		bill.items = em.getBillLedgerItems(bill)
	}


	@ProxyMethod
	public def findOpenLedgerByBill(bill){
		return em.findOpenLedgerById(bill)
	}

	@ProxyMethod
	public def generateBillByLedger(ledger){
		def bill = initBill(ledger.objid)
		bill.billdate = dtSvc.serverDate
		bill.forcerecalcbill = 1
		return generateBill(bill)
	}

	@ProxyMethod
	public def getBillByBarcode(param){
		def bill= em_rptbill.find([barcode:param.barcodeid]).first() 
		if (!bill) 
			throw new Exception('Invalid barcode or associated bill has already expired.')
		if (bill.expirydate <= dtSvc.serverDate) 
			throw new Exception('Bill has already expired.')
		bill.collectiontype = em.findCollectionTypeByBarcodeKey(param)
		if (!bill.collectiontype) 
			throw new Exception('Collection Type is not defined for barcode key ' + param.barcodekey + '.')
		bill.ledgers = em_rptbill_ledger.find([billid:bill.objid]).list().each{ it.objid = it.rptledgerid }
		return bill 
	}	


	def generateBarcode(){
		def cy = dtSvc.serverYear.toString()[-2..-1]
		def lguid = '000'
		if (env){
			if (env.ORGID){
				lguid = env.ORGID.replaceAll('-', '')
			}
		}
		return BARCODE_PREFIX + lguid + cy + seqSvc.getNextFormattedSeriesA('RPTBILL-' + cy,7)
	}

	
	@ProxyMethod
	public void validateAndSetBillParam(bill){
		def pdate = dtSvc.parseCurrentDate()

		bill.forcerecalcbill = 0
		bill.curryear = pdate.year 
		
		if (bill.billdate == null) {
			bill.billdate = pdate.date 
		}
		else{
			bill.billdate = dtSvc.parse('yyyy-MM-dd', bill.billdate)
			def scurrdate = dtSvc.parse('yyyy-MM-dd', dtSvc.format('yyyy-MM-dd', pdate.date))
			def sbilldate = dtSvc.parse('yyyy-MM-dd', dtSvc.format('yyyy-MM-dd', bill.billdate))
			if( sbilldate != scurrdate){
				bill.forcerecalcbill = 1
			}
		}
		bill.billyear = dtSvc.getYear(bill.billdate)

		util.required('Bill To Year', bill.billtoyear)
		util.required('Bill To Qtr', bill.billtoqtr)

		if (bill.billtoyear < bill.rptledger.lastyearpaid)
			throw new Exception('Bill To Year must be greater than or equal to Last Year Paid.')

		if (bill.billtoyear == bill.rptledger.lastyearpaid && bill.billtoqtr <= bill.rptledger.lastqtrpaid && bill.rptledger.partialbasic == 0.0)
			throw new Exception('Bill To Qtr must be greater than Last Qtr Paid.')
		

		def maxbilltoyear = pdate.year + getMaxAllowedAdvanceYear()
		if (bill.billtoyear > maxbilltoyear){
			throw new Exception('Bill To Year must not exceed year ' +  maxbilltoyear + '.')
		}

		if (bill.advancepayment){
			if (bill.billtoyear < pdate.year )
				throw new Exception('Advance Year must be greater than current year.')
		}
		else if (bill.advancebill){
			if ( bill.billdate < bill.currentdate )
				throw new Exception('Advance Billing Date must be greater than current date.')
		}
		
		if (bill.advancebill && bill.billdate <= (pdate.date - 1 ))
            throw new Exception('Advance Billing Date must be greater than current date.')

        if (bill.billtoyear > pdate.year){
        	bill.forcerecalcbill = 1 
        }

        if (util.isTrue(var.landtax_bill_force_recalc)){
        	bill.forcerecalcbill = 1 	
        }
	}


	@ProxyMethod
	public def buildShares(receipt){
		def shares = []
		receipt.rptitems.each{ledger ->
			def bill = receipt.bill 
			bill.rptledgerid = ledger.objid 
			def request = ruleUtilSvc.buildShareRequest(bill, ledger)
			def grps = ['SUMMARY', 'BRGY_SHARE', 'LGU_SHARE', 'PROV_SHARE']
			grps.each{g ->
				ruleSvc.execute( RULESET, request.facts, request.actions, g);
			}
			request.bill.taxes.each{
				it.objid = 'CRA' + new java.rmi.server.UID()
				it.receiptid = receipt.objid 
			}
			shares.addAll(request.bill.taxes)
		}
		return shares.findAll{it.amount > 0}
	}	


	@ProxyMethod
	public def loadProperties(bill){
		bill.billdate = dtSvc.serverDate
		if (!bill.taxpayer) throw new Exception('Taxpayer is required.')
		bill.taxpayerid = bill.taxpayer.objid
		return  em.getBilledLedgers(buildParams(bill))
	}	


	/*========================================================
	*
	* NOTE: billing is now by ledger
	*
	========================================================*/
	@ProxyMethod
	public def buildParams(bill){
		def cdate = dtSvc.parseCurrentDate()
		if (!bill.billdate)
			bill.billdate = dtSvc.serverDate
		def pdate = dtSvc.parseDate(bill.billdate, null)
		def params = [
			rptledgerid : bill.rptledgerid,
			taxpayerid : bill.taxpayerid,
			billtoyear  : bill.billtoyear, 
			billtoqtr   : bill.billtoqtr,
			toyear  	: bill.billtoyear, 
			toqtr   	: bill.billtoqtr, 
			currdate    : cdate.date,
			currentyr   : cdate.year,
			currentqtr  : cdate.qtr,
			nextbilldate : bill.expirydate,
			billdate   : pdate.date,
			billyear   : pdate.year,
			billqtr    : pdate.qtr,
			rputype    : bill.rputype, 
			forpayment : 0,
			billid 		: bill.objid,
		]
		if (bill.rptledgerid) {
			params.filters = ' rl.objid = $P{rptledgerid}'
			params.ppfilters = ' rl.objid = $P{rptledgerid}'
		}
		else {
			params.filters = ' rl.taxpayer_objid = $P{taxpayerid} '
			params.ppfilters = ' pp.taxpayer_objid = $P{taxpayerid} '
		}
		if (bill.rputype ){
			params.filters += ' AND rl.rputype = $P{rputype} '
			params.ppfilters += ' AND rl.rputype = $P{rputype} '
		}

		if (bill.barangay){
			params.barangayid = bill.barangay.objid 
			params.filters += ' AND rl.barangayid = $P{barangayid}'
			params.ppfilters += ' AND rl.barangayid = $P{barangayid}'
		}

		//TODO: temp hack since datasource for MSSQL does not reliably 
		// support order by with limit 
		params.mssqlcountfilter = ''
		params.mysqlcountfilter = ''
		if (bill.payoption && bill.payoption == 'bycount' && bill.itemcount > 0){
			params.mssqlcountfilter = ' TOP ' + bill.itemcount
			params.mysqlcountfilter = ' LIMIT ' + bill.itemcount 
		}
		return params
	}

	@ProxyMethod
	public def getMaxAdvanceYear(  ) {
		return dtSvc.serverYear + 3;
	}

	def getMaxAllowedAdvanceYear(){
		def max_year = var.landtax_collection_max_advance_years_allowed
		if (!max_year) max_year = '3'
		try{
			return new java.math.BigDecimal(max_year.toString()).intValue() 
		}
		catch(e){
			return 3;
		}
	}

	@ProxyMethod
	public def buildBillFromBarcode(barcode){
		def xbill = getBillByBarcode(barcode)
		em_rptbill_ledger.find([billid:xbill.objid]).list().each{
			xbill.rptledgerid = it.rptledgerid 
			generateBill(xbill)
		}
		return xbill
	}


	@ProxyMethod
	public void mergeBillBarcode(bill, barcode){
		if (!em_rptbill.find([objid:bill.objid]).first()){

			bill.dtposted = dtSvc.serverDate
			bill.expirydate = dtSvc.getMonthEndDate(bill.dtposted)
			bill.postedby = env.FULLNAME
			bill.postedbytitle = env.JOBTITLE
			bill.taxpayer.address = bill.taxpayer.address.text
			em_rptbill.create(bill)
		}

		def xbill = getBillByBarcode(barcode)
		em.mergeBillLedger([
			billid  	: bill.objid,
			newbillid   : xbill.objid 
		])

		em_rptbill_ledger.find([billid:bill.objid]).list().each{
			bill.rptledgerid = it.rptledgerid 
			generateBill(bill)
		}
	}


	@ProxyMethod
	public def applyPartialPayment(partial, ledger) {
		def items = ledger.items 
		def partialpmt = partial.amount
		def item = null
		def partialled = false;

		def _items = []
		int idx = 0
		for(; idx <items.size(); idx++){
			item = items[idx]
			
			if (partialpmt >= item.total){
				partialpmt -= item.total
				item.partialled = false 
				_items << item 
			}
			else {
				partialled = true;

				partialpmt = applyPartialFireCode(item, partialpmt)
				partialpmt = applyPartialBasicIdle(item, partialpmt)
				partialpmt = applyPartialSh(item, partialpmt)

				//apply partial to basic and sef
				//distribute evenly 
				if (partialpmt == 0.0 ){
					item.basic 		= 0.0
					item.basicdisc 	= 0.0
					item.basicint 	= 0.0
					item.sef 		= 0.0
					item.sefdisc 	= 0.0
					item.sefint 	= 0.0
				}
				else {
					def netbasic 		= item.basic - item.basicdisc + item.basicint 
					def netsef 			= item.sef - item.sefdisc + item.sefint 
					def linetotal 		= netbasic + netsef 

					def partialpmtbasic    = numSvc.roundA(partialpmt * netbasic / linetotal, 2);
					def partialpmtsef      = numSvc.roundA(partialpmt - partialpmtbasic, 2);
					def basicdiscrate    = item.basicdisc / item.basic
					def sefdiscrate    = item.sefdisc / item.sef

					def partialbasic     = numSvc.round(  partialpmtbasic * item.basic  / netbasic )
					def partialbasicint  = numSvc.round(  partialpmtbasic * item.basicint / netbasic )
					def partialbasicdisc = numSvc.round(  partialbasic * basicdiscrate )

					def partialsef     	= numSvc.round(  partialpmtsef * item.sef  / netsef )
					def partialsefint  	= numSvc.round(  partialpmtsef * item.sefint / netsef )
					def partialsefdisc = numSvc.round(  partialsef * sefdiscrate )

					item.basic 		= partialbasic 
					item.basicdisc 	= numSvc.round( item.basic * basicdiscrate)
					item.basicint 	= partialbasicint
					item.sef 		= partialsef 
					item.sefdisc 	= numSvc.round( item.sef * sefdiscrate)
					item.sefint 	= partialsefint
				}

				item.basicnet 		= item.basic - item.basicdisc + item.basicint
				item.sefnet 		= item.sef - item.sefdisc + item.sefint
				item.totalbasicsef 	= item.basicnet + item.sefnet
				item.total = item.totalbasicsef + item.firecode + (item.basicidle - item.basicidledisc + item.basicidleint)
				item.total += item.basicidle - item.basicidledisc + item.basicidleint
				item.total += item.sh - item.shdisc + item.shint
				item.partialled = true
				_items << item 
				break 
			}
		}
		
		ledger.items = _items 
		ledger.toyear = ledger.items.last().year
		ledger.toqtr = ledger.items.last().qtr
		ledger.totalbasic = ledger.items.basicnet.sum()
		ledger.totalsef = ledger.items.sefnet.sum()
		ledger.totalfirecode = ledger.items.firecode.sum()
		ledger.totalbasicidle = ledger.items.sum{ it.basicidle - it.basicidledisc + it.basicidleint }
		ledger.totalsh = ledger.items.sum{ it.sh - it.shdisc + it.shint }
		ledger.totalgeneral = ledger.totalbasic + ledger.totalfirecode + ledger.totalbasicidle + ledger.totalsh
		ledger.amount = ledger.totalgeneral + ledger.totalsef 
		ledger.partialled = true
		ledger.pay = true 
		return 	ledger 
	}

	def applyPartialFireCode(item, partialpmt){
		if (partialpmt == 0){
			item.firecode = 0.0 
		}
		else if (item.firecode > 0){
			if (partialpmt >= item.firecode){
				partialpmt -= item.firecode 
			}
			else{
				item.firecode = partialpmt
				partialpmt = 0.0 
			}
		}
		return partialpmt
	}

	def applyPartialBasicIdle(item, partialpmt){
		def idletaxtotal = item.basicidle + item.basicidleint - item.basicidledisc
		if (partialpmt == 0){
			item.basicidle 		= 0
			item.basicidledisc 	= 0
			item.basicidleint 	= 0
		}
		else if (idletaxtotal > 0){
			if (partialpmt >= idletaxtotal){
				partialpmt -= idletaxtotal
			}
			else{
				def partialbasicidle     	= numSvc.round(  partialpmt * (item.basicidle - item.basicidledisc) / idletaxtotal )
				def partialbasicidleint  	= numSvc.round(  partialpmt * item.basicidleint / idletaxtotal )
				def partialbasicidledisc 	= numSvc.round(  partialpmt * item.basicidledisc / idletaxtotal )

				item.basicidle 		= partialbasicidle + partialbasicidledisc
				item.basicidledisc 	= partialbasicidledisc
				item.basicidleint 	= partialbasicidleint
				partialpmt = 0.0
			}
		}
		return partialpmt
	}

	def applyPartialSh(item, partialpmt){
		def shtotaltax = item.sh + item.shint - item.shdisc
		if (partialpmt == 0){
			item.sh 	= 0
			item.shdisc = 0
			item.shint 	= 0
		}
		else if (shtotaltax > 0){
			if (partialpmt >= shtotaltax){
				partialpmt -= shtotaltax
			}
			else{
				def partialsh     	= numSvc.round(  partialpmt * (item.sh - item.shdisc) / shtotaltax )
				def partialshint  	= numSvc.round(  partialpmt * item.shint / shtotaltax )
				def partialshdisc 	= numSvc.round(  partialpmt * item.shdisc / shtotaltax )

				item.sh 	= partialsh + partialshdisc
				item.shdisc = partialshdisc
				item.shint 	= partialshint
				partialpmt  = 0.0
			}
		}
		return partialpmt
	}

	@ProxyMethod
	public void checkRestrictions( ledgerid ) {
		
	}

	@ProxyMethod
	public void deletePendingPaymentOrderBills(ledger){
		em.getPaidLedgerBills(ledger).each{bill ->
			em.deleteRptBillLedger(bill)
			em.deleteRptBill(bill)
		}
	}

}
