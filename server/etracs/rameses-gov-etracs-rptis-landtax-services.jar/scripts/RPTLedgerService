import com.rameses.annotations.*
import com.rameses.common.*;
import com.rameses.util.*
import com.rameses.services.extended.*


class RPTLedgerService
{
    @Env
    def env

    @Service()
    def self 

    @Service('DateService')
    def dtSvc

    @Service('NumberService')
    def numSvc 

    @Service('RPTUtil')
    def util

    @Service('RPTBillingService')
    def billingSvc 

    @Service('FAASService')
    def faasSvc

    @ActiveDB('rptledger') 
    def em

    @DataContext('rptledger')
    def em_rptledger

    @DataContext('rptledger_faas')
    def em_rptledger_faas

    @DataContext('rptledger_item')
    def em_rptledger_item

    @DataContext('rptledger_item_qtrly')
    def em_rptledger_item_qtrly

    @DataContext('rptledger_payment')
    def em_rptledger_payment

    @DataContext('rptledger_payment_item')
    def em_rptledger_payment_item

    @DataContext('rptledger_payment_share')
    def em_rptledger_payment_share

    @DataContext('rptledger_subledger')
    def em_rptledger_subledger

    @DataContext('rptledger_credit')
    def em_rptledger_credit

    @DataContext('faas_restriction')
    def em_faas_restriction

    @DataContext('realproperty')
    def em_realproperty

    @DataContext('rptbill')
    def em_rptbill

    @DataContext('rptbill_ledger')
    def em_rptbill_ledger

       

    @ProxyMethod
    public def createLedger( ledger ) {
        def exist = em_rptledger.find([objid:ledger.objid]).first()
        if(exist) return em_rptledger.read(ledger) 
        ledger.advancebill = false;
        em_rptledger.create(ledger)
        em_faas_restriction.find([parent_objid:ledger.faasid]).update([ledger_objid:ledger.objid])
        return ledger 
    }

    @ProxyMethod
    public def updateLedger( ledger ) {
        ledger.advancebill = false;
        ledger.nextbilldate = null;
        ledger.taxable = util.toBoolean(ledger.taxable, true)
        em_rptledger.update(ledger)
        return ledger 
    }    


    @ProxyMethod
    public void deleteLedger( ledger ) {
        em_rptbill_ledger.find([rptledgerid:ledger.objid]).delete() 
        em_rptledger_item_qtrly.find([rptledgerid:ledger.objid]).delete() 
        em_rptledger_item.find([rptledgerid:ledger.objid]).delete() 
        em_rptledger_payment.find([rptledgerid:ledger.objid]).delete() 
        em_rptledger_credit.find([rptledgerid:ledger.objid]).delete() 
        em_rptledger_faas.find([rptledgerid:ledger.objid]).delete() 
    }


    @ProxyMethod
    public void validateAndBuildManualLedger(ledger){
        if (!ledger.fullpin.startsWith(ledger.barangay.pin))
            throw new Exception('PIN is invalid. It must start with ' + ledger.barangay.pin + '.')
        
        ledger.state = 'PENDING'
        ledger.classification = ledger.classification
        ledger.classcode = ledger.classification.code 
        ledger.barangayid = ledger.barangay.objid 
        ledger.owner = ledger.taxpayer
        ledger.taxpayer.address = ledger.taxpayer.address.text 
        ledger.faases = []
        ledger.faases << [
            objid       : 'RF' + new java.rmi.server.UID(),
            state       : 'APPROVED',
            rptledgerid : ledger.objid, 
            faasid      : null,
            tdno        : ledger.tdno, 
            txntype     : ledger.txntype,
            classification  : ledger.classification,
            actualuse       : ledger.classification,
            taxable         : ledger.taxable,
            idleland         : ledger.idleland,
            reclassed       : false,
            backtax         : ledger.backtax, 
            fromyear        : ledger.effectivityyear, 
            fromqtr         : ledger.effectivityqtr, 
            toyear          : 0,
            toqtr           : 0,
            assessedvalue   : ledger.totalav,
            systemcreated   : true,
        ]
    }    

    @ProxyMethod
    public def postNewLedger(faas){
        def ledger = em_rptledger.find([tdno:faas.tdno]).first()
        if (!ledger || (ledger.faasid && ledger.faasid != faas.objid )){
            ledger = createLedgerInfo(faas)
            createLedger(ledger)
            if (! util.isTrue(faas.datacapture)){
                approveLedger(ledger)
            }
        }
        else{
            em_rptledger.find([objid:ledger.objid]).update([faasid:faas.objid])
        }
        return ledger 
    }


    @ProxyMethod
    public def approveLedger( entity ) {
        def old = em_rptledger.find([objid:entity.objid]).first()
        if (!old) throw new Exception('Ledger does not exist or has already been deleted.')
        if (old.state == 'APPROVED') throw new Exception('Ledger has already been approved.')
        if (old.state == 'CANCELLED') throw new Exception('Ledger has already been cancelled.')

        def firstfaas = entity.faases.first()
        def lastfaas = entity.faases.last()

        def info = [:]
        info.state = 'APPROVED'
        info.lastyearpaid     = (lastfaas.fromqtr == 1 ? lastfaas.fromyear - 1 : lastfaas.fromyear)
        info.lastqtrpaid      = (lastfaas.fromqtr == 1 ?  4 : lastfaas.fromqtr - 1)
        info.nextbilldate     = null
        info.advancebill      = false
        entity.putAll(info)

        em_rptledger.find([objid:entity.objid]).update(info)
        em_rptledger_faas.find([rptledgerid:entity.objid]).update([state:entity.state])
        postLedgerItems(entity, dtSvc.serverYear )
        return entity 
    }


    @ProxyMethod
    public def getLedgerItems( entity ) {
        return em_rptledger_item.find([rptledgerid:entity.objid]).orderBy('year desc').list()
    }    

    @ProxyMethod
    public def getPayments(entity) {
        def list = em_rptledger_payment.find([rptledgerid:entity.objid]).orderBy('receiptdate desc,fromyear desc,fromqtr desc').list()
        list.each{
            it.partialled = em_rptledger_payment_item.select('objid')
                                    .find([parentid:it.objid, partialled:1])
                                    .first() != null
        }
        return list 
    }

    @ProxyMethod
    public def getPaymentDetails( payment ) {
        def data = [:]    
        data.items = em_rptledger_payment_item.find([parentid:payment.objid]).orderBy('year desc,qtr desc').list()
        data.shares = em_rptledger_payment_share.find([parentid:payment.objid]).orderBy('sharetype,revperiod,revtype').list()
        return data 
    }


    @ProxyMethod
    public void removeRestriction( restriction ) {
        em_faas_restriction.delete(restriction);
    }

    @ProxyMethod
    public def getRestrictions( entity ) {
        return em_faas_restriction.find(['ledger.objid':entity.objid]).orderBy('txndate').list() 
    }

    @ProxyMethod
    public def postLedgerItemsUptoYear( ledger, toyear ) {
        postLedgerItems(ledger, toyear)
    }

    @ProxyMethod
    public void postLedgerItems( ledger, toyear ) {
        ledger.ledgerfaases = getTaxableLedgerFaases(ledger)

        def startyear = (ledger.lastqtrpaid == 4 ? ledger.lastyearpaid + 1 : ledger.lastyearpaid)
        for (int yr = startyear; yr <= toyear; yr++){
            def item = em_rptledger_item.select('objid, year').find([rptledgerid:ledger.objid, year:yr]).first()
            if (!item){
                postLedgerItem(ledger, yr)
            }
        }

        //delete qtrlyitem less than startqtr 
        def startqtr = (ledger.lastqtrpaid == 4 ? 1 : ledger.lastqtrpaid + 1)
        def p = [objid:ledger.objid, startyear:startyear, startqtr:startqtr]
        em_rptledger_item_qtrly.where('rptledgerid = :objid and year < :startyear and fullypaid = 1', p).delete()
    }

    /* temporary hack: intercepted to adjust av, such as, staggered application */
    @ProxyMethod
    public def calcLedgerItemAssessedValue(params){
        return params
    }    



    @ProxyMethod
    public def getSubLedgers( entity ) {
        return em_rptledger_subledger.find(['parent.objid':entity.objid]).orderBy('subacctno').list()
    }


    @ProxyMethod
    public def createSubLedger( subledger ) {
        createLedger(subledger);
        em_rptledger_subledger.create(subledger)
    }


    @ProxyMethod
    public def updateSubLedger( subledger ) {
        em_rptledger_faas.find([rptledgerid:subledger.objid]).delete()
        em_rptledger.update(subledger)
        em_rptledger_subledger.update(subledger)
    }    

    @ProxyMethod
    public def approveSubLedger( subledger ) {
        def ledger = em_rptledger.read(subledger)
        approveLedger(ledger)
        subledger = em_rptledger_subledger.read(subledger)
        subledger.state = subledger.rptledger.state
        return subledger
    }


    @ProxyMethod
    public void deleteSubLedger(subledger ) {
        em_rptledger_item_qtrly.find([rptledgerid:subledger.objid]).delete()
        em_rptledger_item.find([rptledgerid:subledger.objid]).delete()
        em_rptledger_faas.find([rptledgerid:subledger.objid]).delete()
        em_rptledger_subledger.find([objid:subledger.objid]).delete() 
        em_rptledger.delete(subledger)
    }

    @ProxyMethod
    public void clearNextBillDateByLedger( ledgerid ) {
        em_rptledger.find([objid:ledgerid]).update([nextbilldate:null])
        
    }

    @ProxyMethod
    public void clearNextBillDate() {
        em_rptledger.where('1=1').update([nextbilldate:null])
    }



    @ProxyMethod
    public def fixLedgerFaas(ledgerfaas){
        em_rptledger_faas.save(ledgerfaas)

        //update the ledgeritem AV values with the new AV
        def info = [:]
        info.av = ledgerfaas.assessedvalue
        info.basicav = ledgerfaas.assessedvalue
        info.sefav = ledgerfaas.assessedvalue
        em_rptledger_item.find([rptledgerfaasid:ledgerfaas.objid,fullypaid:0]).update(info)

        //update the ledgeritem_qtrly AV values with the new AV
        def av = ledgerfaas.assessedvalue
        def qtrlyvalue = computeQtrlyValues(av, av, av)

        em.getAffectedQtrlyItemsByLedgerFaas(ledgerfaas).each{
            if (it.qtr == 4) {
                it.av = qtrlyvalue.av4thqtr
                it.basicav = qtrlyvalue.basicav4thqtr
                it.sefav = qtrlyvalue.sefav4thqtr
            }
            else {
                it.av = qtrlyvalue.avqtrly
                it.basicav = qtrlyvalue.basicavqtrly
                it.sefav = qtrlyvalue.sefavqtrly
            }
            em_rptledger_item_qtrly.save(it)
        }

        //reset ledger nextbilldate
        em_rptledger.find([objid:ledgerfaas.rptledgerid]).update([nextbilldate:null])
        generateLedgerBill([objid:ledgerfaas.rptledgerid])
    }

    @ProxyMethod
    public def saveNewRevisionLedgerFaas(ledgerfaas){
        ledgerfaas.state = 'APPROVED'

        //close toyear and toqtr of the latest ledger faas
        def latestfaases = em_rptledger_faas.find([rptledgerid:ledgerfaas.rptledgerid, state:'APPROVED', toyear:0]).list()
        latestfaases.each{lf->
            lf.toyear = (ledgerfaas.fromqtr == 1 ? ledgerfaas.fromyear - 1 : ledgerfaas.fromyear)
            lf.toqtr = (ledgerfaas.fromqtr == 1 ? 4 : ledgerfaas.fromqtr - 1)
            lf.state = 'APPROVED'
            em_rptledger_faas.update(lf)
        }
        em_rptledger_faas.save(ledgerfaas)
        updateLedgerInfoFromNewRevision(ledgerfaas)
        return ledgerfaas   
    }    


    @ProxyMethod
    public def removeLedgerItem( ledgeritem ) {
        em_rptledger_item_qtrly.find([parentid:ledgeritem.objid]).delete()
        em_rptledger_item.delete(ledgeritem)
        em_rptledger.find([objid:ledgeritem.rptledgerid]).update([nextbilldate:null])
    }

    @ProxyMethod
    public def saveLedgerItem( item ) {
        item.basicav = item.av 
        item.sefav = item.av 
        item.classification = item.ledgerfaas.classification
        item.actualuse =  (item.ledgerfaas.actualuse?.objid ? item.ledgerfaas.actualuse : item.ledgerfaas.classification)
        item.basic = 0.0
        item.basicpaid = 0.0
        item.basicint = 0.0
        item.basicintpaid = 0.0
        item.basicdisc = 0.0
        item.basicdisctaken = 0.0
        item.basicidle = 0.0
        item.basicidlepaid = 0.0
        item.basicidledisc = 0.0
        item.basicidledisctaken = 0.0
        item.basicidleint = 0.0
        item.basicidleintpaid = 0.0
        item.sef = 0.0
        item.sefpaid = 0.0
        item.sefint = 0.0
        item.sefintpaid = 0.0
        item.sefdisc = 0.0
        item.sefdisctaken = 0.0
        item.firecode = 0.0
        item.firecodepaid = 0.0
        item.sh = 0.0
        item.shdisc = 0.0
        item.shpaid = 0.0
        item.shint = 0.0
        item.partialled = 0
        item.taxdifference = (item.taxdifference == 1)
        item.qtrly = 0
        em_rptledger_item.save(item)
        createLedgerItemQtrlyData(item)

        // reset billing and recalculate 
        em_rptledger.find([objid:item.rptledgerid]).update([nextbilldate:null])
        generateLedgerBill([objid:item.rptledgerid])
    }    



    @ProxyMethod
    public def updateState(ledger){
        em_rptledger.find([objid:ledger.objid]).update([state:ledger.state])
        em_rptbill_ledger.find([rptledgerid:ledger.objid]).delete() 
        em_rptledger_item_qtrly.find([rptledgerid:ledger.objid]).delete() 
        em_rptledger_item.find([rptledgerid:ledger.objid]).delete() 
        ledger._remarks = 'New State: ' + ledger.state 
        return ledger 
    }

    @ProxyMethod
    public def updateFaasReference(ledger, newfaas){
        def prevtdno = ledger.tdno 
        validateNewFaasReference(ledger, newfaas)
        newfaas = faasSvc.openFaas(newfaas)
        updateLedgerFaasInfo(newfaas, ledger)
        ledger._remarks = 'Previous TD No.: ' + prevtdno  + '  ->  New TD No.: ' + newfaas.tdno 
        return ledger
    }

    @ProxyMethod
    public def getPartialPayment(ledger) {
        def flds = 'basicpaid,basicdisc,basicint,sefpaid,sefdisc,sefint,firecodepaid,'
        flds += 'basicidlepaid,basicidledisc,basicidleint,shpaid,shdisc,shint'
        def p = em_rptledger_item_qtrly.select(flds)
                    .find([rptledgerid:ledger.objid, partialled:1])
                    .first()

        if (!p) {
            p = [
                basicpaid:0.0, sefpaid:0.0, basicidlepaid:0.0,firecodepaid:0
            ]
        }
        p.basicdisctaken = 0
        p.basicintpaid = 0 
        p.sefdisctaken = 0
        p.sefintpaid = 0
        return p
    }

    @ProxyMethod
    public def fixLedger( info ) {
        util.required('Ledger ID', info.objid)
        util.required('TD No.', info.tdno)
        util.required('PIN', info.fullpin)
        util.required('Taxpayer', info.taxpayer)
        info.rptledgerid = info.objid 

        //update ledger info 
        em_rptledger.find([objid:info.objid]).update([
            taxpayer        : info.taxpayer,
            owner           : info.taxpayer,
            tdno            : info.tdno, 
            lastyearpaid    : info.lastyearpaid,
            lastqtrpaid     : info.lastqtrpaid,
            taxable         : info.taxable,
            nextbilldate    : null
        ])

        // clear ledgeritems 
        em_rptledger_item_qtrly.find([rptledgerid:info.rptledgerid]).delete()
        em_rptledger_item.find([rptledgerid:info.rptledgerid]).delete()

        // generate new bill and apply any partial payment
        generateLedgerBill(info)
        updatePartialPaymentInfo(info)
        
        info._remarks = 'Last Year Paid: ' + info.lastyearpaid + ' Last Qtr Paid: ' + info.lastqtrpaid 
        return info 
    }    

    void updatePartialPaymentInfo(info){
        if (info.partial <= 0) return 

        //update qtrly partial payment 
        def qtrlyitem = em_rptledger_item_qtrly.find([rptledgerid:info.objid, year:info.partialledyear, qtr:info.partialledqtr]).first()
        if (!qtrlyitem) throw new Exception('Quarterly Ledger Item does not exist.')
        if (info.basicpaid > qtrlyitem.basic) throw new Exception('Partial for Basic must not exceed ' + numSvc.format('#,##0.00', qtrlyitem.basic) + '.')
        if (info.sefpaid > qtrlyitem.sef) throw new Exception('Partial for SEF must not exceed ' + numSvc.format('#,##0.00', qtrlyitem.sef) + '.')
        qtrlyitem.basicpaid = info.basicpaid         
        qtrlyitem.sefpaid = info.sefpaid         
        em_rptledger_item_qtrly.update(qtrlyitem)

        // update ledgeritem partial payment
        def ledgeritem = em_rptledger_item.find([rptledgerid:info.objid, year:info.partialledyear]).first() 
        ledgeritem.basicpaid = info.basicpaid 
        ledgeritem.sefpaid = info.sefpaid 
        em_rptledger_item.update(ledgeritem)

        // reset billing and recalculate 
        info.partial = 0
        em_rptledger.find([objid:info.objid]).update([nextbilldate:null])
        generateLedgerBill(info)
    }

    @ProxyMethod
    public def checkLedgerApprovedState(faasid){
        def ledger = em_rptledger.select('state').find([faasid:faasid]).first()
        if (!ledger) 
            throw new Exception('Ledger does not exist or has already been deleted.')
        if (ledger.state == 'CANCELLED')
            throw new Exception('Ledger has already been cancelled.')
        if (ledger.state == 'PENDING')
            throw new Exception('Ledger is still pending.')
    }


    @ProxyMethod
    public void checkLedgerBalance(faasid){
        def ledger = em.findApprovedLedgerByFaasId([faasid:faasid])
        if (!ledger)
            throw new Exception('Ledger does not exist or has already been deleted.')

        def pdate = dtSvc.parseCurrentDate();
        if (util.isTrue(ledger.taxable)) {
            if ( ledger.lastyearpaid < pdate.year || (ledger.lastyearpaid == pdate.year && ledger.lastqtrpaid < pdate.qtr))
                throw new Exception('Ledger has not yet been fully paid.')
            if (util.isTrue(ledger.undercompromise))
                throw new Exception('Ledger is still under compromised.')
        }
        else {
            em_rptledger.find([objid:ledger.objid]).update([toyear:dtSvc.serverYear, toqtr:4, nextbilldate:null])
        }
    }    

    @ProxyMethod
    public void postPayment( payment ) {
        payment.dtposted = dtSvc.serverDate 
        payment.postedby = env.NAME
        payment.postedbytitle = env.JOBTITLE
        payment.voided = false 
        payment.rptledger = [objid:payment.rptledgerid]
        def len = payment.paidby.name.length()
        if (len > 100 ) len = 100
        payment.paidby = payment.paidby
        em_rptledger_payment.create(payment)

        if (payment.fromyear < payment.toyear){
            //delete items less than toyear 
            em_rptledger_item_qtrly.where('rptledgerid = :rptledgerid and year < :toyear ', payment).delete()
            em_rptledger_item.where('rptledgerid = :rptledgerid and year < :toyear ', payment).delete()
        }
        
        if (payment.toqtr == 4){
            //to year is fully paid, delete items 
            em_rptledger_item_qtrly.where('rptledgerid = :rptledgerid and year = :toyear ', payment).delete()
            em_rptledger_item.where('rptledgerid = :rptledgerid and year = :toyear ', payment).delete()
        }
        else {
            //not fully paid 
            def qtrlyitems = em_rptledger_item_qtrly.where('rptledgerid = :rptledgerid and year = :toyear and qtr <= :toqtr', payment).list() 
            if (qtrlyitems){
                qtrlyitems.each{
                    it.fullypaid = true 
                    it.partialled = false
                    it.basicpaid = it.basic 
                    it.basicidlepaid = it.basicidle 
                    it.sefpaid = it.sef 
                    it.firecodepaid = it.firecode 
                    em_rptledger_item_qtrly.update(it)
                }
                em_rptledger_item.find([objid:qtrlyitems[0].parentid]).update([
                        fullypaid : 0,
                        basicpaid : qtrlyitems.basicpaid.sum(),
                        basicidlepaid : qtrlyitems.basicidlepaid.sum(),
                        sefpaid : qtrlyitems.sefpaid.sum(),
                        firecodepaid : qtrlyitems.firecodepaid.sum(),
                ])
            }
        }

        //reset and recalc bill 
        em_rptledger.find([objid:payment.rptledgerid]).update([
                nextbilldate    : null,
                lastyearpaid    : payment.toyear,
                lastqtrpaid     : payment.toqtr
            ])

        generateLedgerBill([objid:payment.rptledgerid])
    }

    @ProxyMethod
    public void postLedgerFaasData(faas){
        if (!faas.previousfaases) return
        def ledger = em_rptledger.find([faasid:faas.previousfaases[0].prevfaasid]).first()
        if (!ledger){
            ledger = em_rptledger.find([tdno:faas.prevtdno, taxpayer_objid:faas.taxpayer?.objid]).first() 
        }
        if (ledger){
            ledger.faasid = faas.objid 
            updateLedger(ledger)
            def ledgerfaas = createLedgerFaas(ledger, faas)
            postLedgerFaas(ledgerfaas) 
            postTaxDifference(ledger, ledgerfaas, faas)
            updateLedgerFaasInfo(faas, ledger)
        }
    }


    void postTaxDifference(ledger, ledgerfaas, faas){
        if (ledger.lastyearpaid < faas.effectivityyear)
            return

        //post tax difference 
        def params = [
            rptledgerid:ledger.objid, 
            effectivityyear:faas.effectivityyear,
            effectivityqtr : faas.effectivityqtr,
            currentav : faas.rpu.totalav,
            toyear : (faas.effectivityqtr == 1 ? faas.effectivityyear - 1 : faas.effectivityyear), 
            toqtr : (faas.effectivityqtr == 1 ? 4 : faas.effectivityqtr - 1), 
        ]

        
        //get items with tax differences
        def taxdiffitems = em.getLedgerItemsWithTaxDifference(params)

        taxdiffitems.each{
            it.objid = 'RLI' + new java.rmi.server.UID() 
            it.rptledgerfaasid = ledgerfaas.objid 
            it.av = it.avdifference 
            it.basicav = it.avdifference 
            it.sefav = it.avdifference 
            it.qtrly = 0
            it.fullypaid = 0 
            it.remarks = 'Tax Difference for ' + it.year 
            it.taxdifference = 1
            it.basic           = 0.0
            it.basicpaid       = 0.0
            it.basicint        = 0.0
            it.basicintpaid    = 0.0
            it.basicdisc       = 0.0
            it.basicdisctaken  = 0.0
            it.basicidle       = 0.0
            it.basicidlepaid   = 0.0
            it.basicidledisc   = 0.0
            it.basicidledisctaken = 0.0
            it.basicidleint       = 0.0
            it.basicidleintpaid   = 0.0
            it.sef             = 0.0
            it.sefpaid         = 0.0
            it.sefint          = 0.0
            it.sefintpaid      = 0.0
            it.sefdisc         = 0.0
            it.sefdisctaken    = 0.0
            it.firecode        = 0.0
            it.firecodepaid    = 0.0
            it.sh             = 0.0
            it.shpaid         = 0.0
            it.shint          = 0.0
            it.shintpaid      = 0.0
            it.shdisc         = 0.0
            it.shdisctaken    = 0.0
            it.partialled      = 0
            em_rptledger_item.create(it, SCHEMA_ITEM)
        }

        // update last year and qtr paid, reset nextbilldate
        em_rptledger.find([objid:ledger.objid]).update([lastyearpaid:params.toyear, lastqtrpaid:params.toqtr, nextbilldate:null])
    }


    @ProxyMethod
    public def postLedgerFaas( ledgerfaas ) {
        def ledgerfaases = em_rptledger_faas.find([rptledgerid:ledgerfaas.rptledgerid]).orderBy('fromyear desc, tdno desc')
        def latestledgerfaas = ledgerfaases.first()
        if (latestledgerfaas) {
            if (latestledgerfaas.fromyear == ledgerfaas.fromyear && latestledgerfaas.fromqtr == ledgerfaas.fromqtr){
                latestledgerfaas.state = STATE_CANCELLED 
                latestledgerfaas.toyear = latestledgerfaas.fromyear 
            }
            else {
                latestledgerfaas.toyear = (ledgerfaas.fromqtr == 1 ? ledgerfaas.fromyear - 1 : ledgerfaas.fromyear)
            }
            latestledgerfaas.toqtr = (ledgerfaas.fromqtr == 1 ? 4 : ledgerfaas.fromqtr - 1)
            em_rptledger_faas.save(latestledgerfaas)
        }
        em_rptledger_faas.save(ledgerfaas)
    }    



    void updateLedgerInfoFromNewRevision(ledgerfaas){
        def info = [
            fullpin     : ledgerfaas.fullpin,
            tdno        : ledgerfaas.tdno, 
            txntype     : ledgerfaas.txntype, 
            classification : ledgerfaas.classification,
            classcode      : ledgerfaas.classification.code,
            totalav        : ledgerfaas.assessedvalue, 
            taxable         : ledgerfaas.taxable 
        ]
        em_rptledger.find([objid:ledgerfaas.rptledgerid]).update(info)
    }


    void generateLedgerBill(info){
        try{
            def cy = dtSvc.serverYear 
            def bill = billingSvc.initBill(info.objid)
            if (info.partial > 0 && info.lastyearpaid >= cy){
                bill.billtoyear = cy + 1 
            }
            billingSvc.generateBill(bill)
        }
        catch(e){
            println 'generateLedgerBill [ERROR]: ' + e.message 
        }
    }



    @ProxyMethod
    public def getTaxableLedgerFaases(ledger){
        return em_rptledger_faas.find([rptledgerid:ledger.objid,state:'APPROVED',taxable:true])
                                .orderBy('fromyear,fromqtr')
                                .list()
    }


    void postLedgerItem(ledger, yr){
        def ledgerfaases = ledger.ledgerfaases.findAll{
                if (yr >= it.fromyear && (yr <= it.toyear || it.toyear == 0))
                    return true 
                return false 
            }

        ledgerfaases.each{ledgerfaas->
            def params = [
                ledger      : ledger, 
                ledgerfaas  : ledgerfaas, 
                yr          : yr, 
                av          : ledgerfaas.assessedvalue, 
                basicav     : ledgerfaas.assessedvalue, 
                sefav       : ledgerfaas.assessedvalue, 
                classification   : ledgerfaas.classification,
                actualuse   : (ledgerfaas.actualuse?.objid ? ledgerfaas.actualuse : ledgerfaas.classification),
            ]

            // if no item for this yr and actualuse
            // create the item and qtrlyitem based on the recalculated "capping" av
            def olditem = em_rptledger_item.find([objid:ledger.objid, year:yr, 'actualuse.objid':params.actualuse.objid]).first()
            if (!olditem){
                //allow interceptors to adjust av based on capping
                self.calcLedgerItemAssessedValue(params)

                def item = createLedgerItemData(ledger, ledgerfaas, params, yr)
                createLedgerItemQtrlyData(item)
            }
        }        
    }

    def createLedgerItemData(ledger, ledgerfaas, params, yr){
        def item = [
            objid           : 'RLI' + new java.rmi.server.UID(), 
            rptledgerid     : ledger.objid, 
            rptledgerfaasid : ledgerfaas.objid, 
            av              : params.av, 
            basicav         : params.basicav,
            sefav           : params.sefav,
            taxdifference   : 0,
            classification  : params.classification,
            actualuse       : params.actualuse,
            remarks         : (params.av != ledgerfaas.assessedvalue ? 'Staggered AV' : 'Annual Receivable'),
            year            : yr, 
            basic           : 0.0,
            basicpaid       : 0.0,
            basicint        : 0.0,
            basicdisc       : 0.0,
            basicidle       : 0.0,
            basicidlepaid   : 0.0,
            basicidledisc   : 0.0,
            basicidleint    : 0.0,
            sef             : 0.0,
            sefpaid         : 0.0,
            sefint          : 0.0,
            sefdisc         : 0.0,
            firecode        : 0.0,
            firecodepaid    : 0.0,
            sh             : 0.0,
            shpaid         : 0.0,
            shint          : 0.0,
            shdisc         : 0.0,
            partialled      : 0,
            qtrly           : 0,
            fullypaid       : 0,
        ]
        em_rptledger_item.save(item)
        return item
    }    

    def computeQtrlyValues(av, basicav, sefav){
        def value = [:]
        value.avqtrly = numSvc.round( av / 4)
        value.av4thqtr = av - (value.avqtrly * 3)
        value.basicavqtrly = numSvc.round( basicav / 4)
        value.basicav4thqtr = basicav - (value.basicavqtrly * 3)
        value.sefavqtrly = numSvc.round( sefav / 4)
        value.sefav4thqtr = sefav - (value.sefavqtrly * 3)
        return value 
    }

    void createLedgerItemQtrlyData(item){
        def qtrlyvalue = computeQtrlyValues(item.av, item.basicav, item.sefav)

        for(int qtr=1; qtr<=4; qtr++ ){
            def itemid = item.objid 
            def qtritem = [itemid:itemid]
            qtritem.putAll(item)
            qtritem.objid = itemid + '-' + qtr 
            qtritem.parentid = itemid 
            qtritem.qtr = qtr 
            qtritem.av = (qtr == 4 ? qtrlyvalue.av4thqtr : qtrlyvalue.avqtrly)
            qtritem.basicav = (qtr == 4 ? qtrlyvalue.basicav4thqtr : qtrlyvalue.basicavqtrly)
            qtritem.sefav = (qtr == 4 ? qtrlyvalue.sefav4thqtr : qtrlyvalue.sefavqtrly)
            qtritem.fullypaid = 0
            em_rptledger_item_qtrly.save(qtritem)
        }
    }    


    def createLedgerInfo(faas){
        faas.rp = em_realproperty.find([objid:faas.rp.objid]).first()
        def ledger = [
            objid                   : faas.objid,
            state                   : 'PENDING',
            faasid                  : faas.objid,
            basic                   : 0.0,
            basicint                : 0.0,
            basicdisc               : 0.0,
            basiccredit             : 0.0,
            sef                     : 0.0,
            sefint                  : 0.0,
            sefdisc                 : 0.0,
            sefcredit               : 0.0,
            nextbilldate            : null, 
            lastyearpaid            : 0,
            lastqtrpaid             : 0,
            idleland                : faas.rpu.idleland,
            faases                  : [],
            barangayid              : faas.rp.barangay.objid,
            taxpayer                : faas.taxpayer,
            owner                   : faas.owner,
            administrator           : faas.administrator,
            fullpin                 : faas.fullpin,
            tdno                    : faas.tdno,
            cadastrallotno          : faas.rp.cadastrallotno,
            blockno                 : faas.rp.blockno,
            rputype                 : faas.rpu.rputype,
            txntype                 : faas.txntype, 
            classcode               : faas.rpu.classification.code,
            classification          : faas.rpu.classification,
            totalav                 : faas.rpu.totalav, 
            totalmv                 : faas.rpu.totalmv, 
            totalareaha             : faas.rpu.totalareaha, 
            taxable                 : util.toBoolean(faas.rpu.taxable, true), 
            prevtdno                : faas.prevtdno,
            titleno                 : faas.titleno,
        ]

        ledger.faases << createLedgerFaas( ledger, faas )
        def lastfaas = ledger.faases.last() 
        faas.backtaxes?.each{ backtax ->
            backtax.txntype         = faas.txntype 
            backtax.rpu             = faas.rpu 
            backtax.backtaxyrs      = faas.backtaxyrs
            backtax.taxable         = util.toBoolean(backtax.taxable, true)
            def ledgerfaas          = createLedgerFaas(ledger, backtax)
            ledgerfaas.faasid       = backtax.faasid 
            ledgerfaas.assessedvalue = backtax.av 
            ledgerfaas.backtax      = true 
            ledgerfaas.toyear       = (lastfaas.fromqtr == 1 ? lastfaas.fromyear - 1 : lastfaas.fromyear)
            ledgerfaas.toqtr        = (lastfaas.fromqtr == 1 ? 4 : lastfaas.fromqtr - 1)
            ledger.faases << ledgerfaas 
            lastfaas = ledgerfaas
        }
        return ledger 
    }    


    def createLedgerFaas(ledger, faas){
        return [
            objid             : faas.objid,
            state             : ledger.state,
            rptledgerid       : ledger.objid,
            faasid            : faas.objid, 
            tdno              : faas.tdno,
            txntype           : faas.txntype,
            classification    : faas.rpu.classification,
            actualuse         : faas.rpu.classification,
            taxable           : util.toBoolean(faas.rpu.taxable, true),
            backtax           : (faas.backtaxyrs > 0 ),
            fromyear          : faas.effectivityyear,
            fromqtr           : faas.effectivityqtr,
            toyear            : 0,
            idleland          : (faas.rpu.idleland ? 1 : 0),
            toqtr             : 0,
            assessedvalue     : faas.rpu.totalav,
            systemcreated     : true,
            reclassed         : util.toBoolean(faas.rpu.reclassed, false),
        ]
    }

    void validateNewFaasReference(ledger, faas){
        if (faas.state != 'CURRENT')
            throw new Exception('FAAS is not yet current. Only current FAAS is allowed.');
        if (ledger.rputype != faas.rputype)
            throw new Exception('FAAS proeprty type is invalid. Only ' + ledger.rputype + ' property type is allowed.');

        //check duplicate reference
        def existing = em_rptledger.select('objid').find([faasid:faas.objid]).first()
        if(existing && ledger.objid != existing.objid){
            throw new Exception('FAAS is already referenced by Ledger with TD No. ' + existing.tdno + '.')
        }
    }

    void updateLedgerFaasInfo(faas, ledger){
        faas.rp = em_realproperty.find([objid:faas.rp.objid]).first()
        ledger.faasid          = faas.objid 
        ledger.taxpayer        = faas.taxpayer
        ledger.owner           = faas.owner
        ledger.administrator   = faas.administrator
        ledger.fullpin         = faas.fullpin
        ledger.tdno            = faas.tdno
        ledger.cadastrallotno  = faas.rp.cadastrallotno
        ledger.blockno         = faas.rp.blockno
        ledger.rputype         = faas.rpu.rputype
        ledger.txntype         = faas.txntype
        ledger.classcode       = faas.rpu.classification.code
        ledger.classification  = faas.rpu.classification
        ledger.totalav         = faas.rpu.totalav
        ledger.totalmv         = faas.rpu.totalmv
        ledger.totalareaha     = faas.rpu.totalareaha
        ledger.taxable         = util.toBoolean(faas.rpu.taxable, true)
        ledger.prevtdno        = faas.prevtdno
        ledger.titleno         = faas.titleno
        ledger.advancebill     = false;
        ledger.nextbilldate    = null;
        em_rptledger.find([objid:ledger.objid]).update(ledger)
    }    

}


