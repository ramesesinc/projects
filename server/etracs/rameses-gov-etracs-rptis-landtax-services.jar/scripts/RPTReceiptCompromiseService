import com.rameses.annotations.*
import java.rmi.server.*;
import com.rameses.common.*
import com.rameses.rules.common.*;
import com.rameses.services.extended.*
import rptis.landtax.facts.*;
import rptis.landtax.actions.*;

class RPTReceiptCompromiseService
{
	@ActiveDB('rptcompromise')
	def em

	@ActiveDB('cashreceiptrpt')
	def receiptdb 

	@Service('DateService')
	def dtSvc

	@Service('NumberService')
	def numSvc

	@Service('RPTBillingService')
	def billingSvc

	@Resource("RuleService")
	def ruleSvc;

	@Service('RPTLedgerService')
	def ledgerSvc 


	@Service('LGUService')
	def lguSvc 

	@Service('RPTReceiptService')
	def receiptSvc

	@DataContext('rptledger')
	def em_rptledger

	@DataContext('rptcompromise')
	def em_compromise

	@DataContext('rptpayment')
	def em_rptpayment

	@DataContext('rptpayment_item')
	def em_rptpayment_item

	@DataContext('rptpayment_share')
	def em_rptpayment_share



	
	def RULESET 			= 'rptbilling'
	def FACT_PACKAGE 		= 'rptbilling.'

	@ProxyMethod
	public def open(receipt  ) {
		def r = receiptdb.read(receipt)
		if (r){
			receipt.putAll(r)
			if (receipt.txntype == 'rptcompromise'){
				receipt.compromise = em.findCompromiseByReceipt(receipt)
				if (receipt.objid == receipt.compromise.cypaymentreceiptid || 
					receipt.objid == receipt.compromise.downpaymentreceiptid){
					receipt.requiredpayment = [:]
					if (receipt.objid == receipt.compromise.downpaymentreceiptid)
						receipt.requiredpayment.type = 'downpayment'
					else 
						receipt.requiredpayment.type = 'cypayment'
				}
			}
		}

	}


	@ProxyMethod
	public def getUnpaidInstallments( objid ) {
		return em.getUnpaidInstallments([rptcompromiseid:objid])
	}

	@ProxyMethod
	public def getCurrentYearDue( ledgerid ) {
		def bill = billingSvc.generateBillByLedger([objid:ledgerid])	
		def due = em.findCurrentDueByBill(bill)
		if (!due) throw new Exception('Current Due is not computed property. Verify ledger data.')
		bill.currentyeardue = due.amount 
		return bill 
	}

	@ProxyMethod
	public def createReceipt(receipt){
		def pdate = dtSvc.parseDate(receipt.txndate, null)
		receipt.year = pdate.year
		receipt.qtr = pdate.qtr
		receipt.month = pdate.month
		receipt.day = pdate.day
		receiptdb.create(receipt)

		def compromiseparam = [objid:receipt.compromise.objid, amtpaid:receipt.amount, rptledgerid:receipt.compromise.rptledgerid]

		if (receipt.requiredpayment == null ){
			receipt._ledgerpmt = createLedgerPayment(receipt)
			postInstallmentPayments(receipt)
			postPaidItems(receipt)
			postTaxes(receipt)
			em.updateCompromiseAmountPaid(compromiseparam)
			updateLedgerCompromiseInfo(compromiseparam)
		}
		else if (receipt.requiredpayment.type == 'downpayment'){
			receipt._ledgerpmt = createLedgerPayment(receipt)
			receipt.remarks = (receipt.remarks ? receipt.remarks : 'Downpayment')
			postRequiredPayment(receipt)
			postPaidItems(receipt)
			postRequiredPaymentCredit(receipt)
			postTaxes(receipt)
			em.updateCompromiseAmountPaid(compromiseparam)
		}
		else {
			receipt.remarks = (receipt.remarks ? receipt.remarks : 'Current year payment')
			postRequiredPayment(receipt)
			postRequiredPaymentCredit(receipt)
			receipt.rptitems = receiptSvc.getItemsForPayment(receipt.bill)
			receipt.billid = receipt.bill.objid 
			receiptSvc.createReceipt(receipt)
		}
		em.clearNextBillDate(compromiseparam)
	}

	def createLedgerPayment(receipt){
		def pmt = [:]
		pmt.objid = 'RLP' + new java.rmi.server.UID()
		pmt.rptledgerid = receipt.compromise.rptledgerid
		pmt.rptledger = [objid:receipt.compromise.rptledgerid]
		pmt.type = receipt.txntype 
		pmt.receiptid = receipt.objid 
		pmt.receiptno = receipt.receiptno 
		pmt.receiptdate = receipt.receiptdate 
		pmt.paidby_name = receipt.paidby 
		pmt.paidby_address = receipt.paidbyaddress 
		pmt.postedby = receipt.collector?.name 
		pmt.postedbytitle = receipt.collector?.title 
		pmt.dtposted = receipt.txndate 
		pmt.fromyear = receipt.paiditems.first().year 
		pmt.fromqtr = receipt.paiditems.first().qtr 
		pmt.toyear = receipt.paiditems.last().year 
		pmt.toqtr = receipt.paiditems.last().qtr 
		pmt.amount = receipt.amount 
		pmt.voided = false
		em_rptpayment.create(pmt)
		return pmt 
	}

	void updateLedgerCompromiseInfo(param){
		def comp = em_compromise.select('state').find([objid:param.objid]).first()
		if(comp && 'CLOSED'.equalsIgnoreCase(comp.state)){
			em_rptledger.find([objid:param.rptledgerid]).update([undercompromise:0])
		}
	}

	void postTaxes(receipt){
		def ledgerpmt = receipt._ledgerpmt
		receipt.taxes.each {
			it.parentid = ledgerpmt.objid 
			it.rptreceiptid = receipt.objid 
			em_rptpayment_share.create(it)
		}

	}


	void postPaidItems(receipt){
		receipt.paiditems.each{ item ->
			buildPaidItemInfo(receipt, item)
			em_rptpayment_item.create(item)
			em.create(item, 'rptcompromise_item_credit')

			if (item.fullypaid == 1 || item.fullypaid == true )
				em.fullyPaidCompromiseItem(item)
			else 
				em.partiallyPaidCompromiseItem(item)
		}
	}

	def buildPaidItemInfo(receipt, item){
		def ledgerpmt = receipt._ledgerpmt
		def objid = 'RI' + new java.rmi.server.UID()
		def itemid = item.objid 
		item.objid = objid
		item.parentid = ledgerpmt.objid 
		item.itemid = itemid 
		item.rptcompromiseitemid = itemid 
		item.rptledgerid = receipt.compromise.rptledgerid
		item.rptreceiptid = receipt.objid 
		item.basicdisc = 0.0
		item.basicidledisc = 0.0
		item.sefdisc = 0.0
		item.shdisc = 0.0
		item.partialled = (item.partial == 1 ? 1 : 0)
		item.fromyear = item.year 
		item.toyear = item.year 
		item.fromqtr = 1
		item.toqtr = 4
		item.revperiod = (item.revperiod ? item.revperiod : 'previous')
		if (item.qtr > 0){
			item.fromqtr = item.qtr
			item.toqtr = item.qtr 
		}
		return item
	}

	void postInstallmentPayments(receipt){
		receipt.installments.findAll{it.pay == true}.each{
			def credit = createCredit(receipt, it)
			em.create(credit, 'rptcompromise_credit')
			em.postInstallmentPayment(it)
		}
	}

	void postRequiredPayment(receipt){
		receipt.rptcompromiseid = receipt.compromise.objid  
		if (receipt.requiredpayment.type == 'downpayment')
			em.updateDownpaymentPaymentInfo(receipt)
		else 
			em.updateCurrentYearPaymentInfo(receipt)
	}


	@ProxyMethod
	public void voidReceipt(receipt) {
		def compromise = em.findCompromiseByReceiptForVoiding(receipt)
		if (!compromise)
			throw new Exception('Compromise receipt does not exist or has already been deleted.')

		def oldcomp = em.read([objid:compromise.rptcompromiseid])
		if (!oldcomp)
			throw new Exception('Compromise record does not exist or has already been deleted.')

		compromise.downpaymentreceiptid = null
		compromise.downpaymentorno = null
		compromise.downpaymentordate = null
		compromise.cypaymentreceiptid = null
		compromise.cypaymentorno = null
		compromise.cypaymentordate = null
		compromise.debitamount = receipt.amount 

		if (oldcomp.downpaymentreceiptid == compromise.rptreceiptid){
			em.updateDownpaymentPaymentInfo(compromise)
		}
		else if (oldcomp.cypaymentreceiptid == compromise.rptreceiptid){
			compromise.debitamount = 0.0 
			em.updateCurrentYearPaymentInfo(compromise)
			em.updateLedgerLastYearQtrPaid(oldcomp)
			fixLedgerInfo(oldcomp)
		}
		
		em.voidCompromiseCredit(compromise)
		em.voidItemCredits(compromise)
		em.voidInstallmentCredits(compromise)
		em.deleteVoidedItemCredit(compromise)
		em.deleteVoidedCredit(compromise)
		em_rptpayment.find([receiptid:receipt.objid]).update([voided:true])

	}

	void fixLedgerInfo(compromise){
		def ledger = em.findLedgerById([objid:compromise.rptledgerid])
		if (!ledger) 
			throw new Exception('Ledger does not exist or has already been deleted.')

		def info = [:]
		info.objid = ledger.objid
		info.tdno = ledger.tdno
		info.fullpin = ledger.fullpin
		info.taxpayer = ledger.taxpayer
		info.lastyearpaid = compromise.endyear 
		info.lastqtrpaid = compromise.endqtr 
		info.taxable = ledger.taxable 
		info.basicpaid = 0.0
		info.basicintpaid = 0.0
		info.basicdisctaken = 0.0
		info.sefpaid = 0.0
		info.sefintpaid = 0.0
		info.sefdisctaken = 0.0
		ledgerSvc.fixLedger(info)
	}

	
	@ProxyMethod
	public def getItemsForPrinting( receipt ) {
		receipt.installments = em.getPaidInstallmentsByReceipt(receipt)
		def installmentnos = receipt.installments.installmentno.join(',')
		def haspartial = (receipt.installments.find{it.fullypaid == 0 } != null)

		return receiptSvc.getItemsForPrinting(receipt).each{
			if (receipt.requiredpayment){
				if (receipt.requiredpayment.type == 'downpayment')
					it.period = 'CO# ' + receipt.compromise.txnno +'\n Downpayment '
				else 
					it.period = 'CO# ' + receipt.compromise.txnno +'\n ' + it.fromyear + ' payment'
			}
			else{
				if (haspartial)
					it.period = 'CO# ' + receipt.compromise.txnno +'\nInstallment ' + installmentnos + ' (Partial)'
				else 	
					it.period = 'CO# ' + receipt.compromise.txnno +'\nInstallment ' + installmentnos 
			} 
		}
	}


	void updateTotals(item){
		item.amtdue = item.basic + item.basicint + item.basicidle + item.basicidleint 
		item.amtdue += item.sef + item.sefint + item.firecode 
		item.amtdue += item.sh + item.shint
		item.basicnet = item.basic + item.basicint 
		item.sefnet = item.sef + item.sefint 
		item.totalbasicsef = item.basicnet + item.sefnet
		item.total = item.amtdue 
	}

	@ProxyMethod
	public def buildCreditAndTaxItems(receipt){
		def compromise = receipt.compromise 
		def unpaiditems = em.getUnpaidItems(compromise).each{ updateTotals(it) }
		
		def payment = receipt.amount 
		def paiditems = []

		//build paiditems 
		for (int i=0; i < unpaiditems.size(); i++){
			def item = unpaiditems[i]
			item.paid = 0

			if (payment <= 0.0){
				break;
			}
			else if (item.amtdue <= payment){
				item.paid = 1
				paiditems << item
				payment -= item.amtdue 
			}
			else{
				payment = applyPartialFireCode( item, payment)
				payment = applyPartialBasicIdle(item, payment)
				payment = applyPartialSh(item, payment)
				
				if (payment > 0.0){
					def linedue = item.basic + item.basicint + item.sef + item.sefint
					def partialbasic = numSvc.round( (item.basic / linedue) * payment )
					def partialbasicint = numSvc.round( (item.basicint / linedue) * payment )
					def partialsef = numSvc.round( (item.sef / linedue) * payment )
					def partialsefint = payment - (partialbasic + partialbasicint + partialsef )
					item.basic = partialbasic 
					item.basicint = partialbasicint 
					item.sef = partialsef 
					item.sefint = partialsefint 
				}
				else{
					item.basic = 0
					item.basicint = 0
					item.sef = 0
					item.sefint = 0
				}
				item.paid = 0

				updateTotals(item)
				paiditems << item
				payment = 0.0
			}
		}

		receipt.paiditems = paiditems 
		buildShares(receipt)
		receipt.paiditems.each{
			it.fullypaid = it.paid 
		}
		return receipt
	}

	def applyPartialFireCode(item, payment){
		if (payment == 0){
			item.firecode = 0.0 
		}
		else if (item.firecode > 0){
			if (payment >= item.firecode){
				payment -= item.firecode 
			}
			else{
				item.firecode = payment
				payment = 0.0 
			}
		}
		return payment
	}	

	def applyPartialBasicIdle(item, payment){
		def idletaxtotal = item.basicidle + item.basicidleint 
		if (payment == 0){
			item.basicidle 		= 0
			item.basicidleint 	= 0
		}
		else if (idletaxtotal > 0){
			if (payment >= idletaxtotal){
				payment -= idletaxtotal
			}
			else{
				def partialbasicidle     	= numSvc.round(  payment * item.basicidle / idletaxtotal )
				def partialbasicidleint  	= numSvc.round(  payment * item.basicidleint / idletaxtotal )

				item.basicidle 		= partialbasicidle 
				item.basicidleint 	= partialbasicidleint
				payment = 0.0
			}
		}
		return payment
	}


	def applyPartialSh(item, payment){
		def shtotaltax = item.sh + item.shint
		if (payment == 0){
			item.sh 	= 0
			item.shint 	= 0
		}
		else if (shtotaltax > 0){
			if (payment >= shtotaltax){
				payment -= shtotaltax
			}
			else{
				def partialsh     	= numSvc.round(  payment * item.sh / shtotaltax )
				def partialshint  	= numSvc.round(  payment * item.shint / shtotaltax )
				item.sh 	= partialsh
				item.shint 	= partialshint
				payment  = 0.0
			}
		}
		return payment
	}




	def createCapturedReceipt(compromise, pmt){
		return [
			compromise 	: compromise,
			ledger  	: [objid:compromise.rptledgerid],
			collector   : pmt.collector,
			receiptno   : pmt.orno,
			receiptdate : pmt.ordate,
			amount 		: pmt.amount,
			mode 		: 'CAPTURE',
			paidby 		: pmt.paidby,
			paidbyaddress : pmt.paidbyaddress,
		]
	}

	@ProxyMethod
	public void postCapturedInstallmentPayment( compromise, pmt, installments ){
		def receipt = createCapturedReceipt(compromise, pmt)
		receipt.installments = installments
		postInstallmentPayments(receipt)
		buildCreditAndTaxItems(receipt)
		receipt.paiditems.each{ item ->
			buildPaidItemInfo(receipt, item)
			em_rptpayment_item.create(item)
			if (item.fullypaid == 1 || item.fullypaid == true )
				em.fullyPaidCompromiseItem(item)
			else 
				em.partiallyPaidCompromiseItem(item)
		}
		updateCompromiseAmountPaid(compromise, pmt)
	}	


	@ProxyMethod
	public def postCapturedDownpayment(compromise, pmt){
		def receipt = createCapturedReceipt(compromise, pmt)
		receipt.amount = compromise.downpayment
		receipt.remarks = 'Payment for Downpayment'
		buildCreditAndTaxItems(receipt)

		receipt.paiditems.each{ item ->
			buildPaidItemInfo(receipt, item)
			em.create(item, 'rptcompromise_item_credit')
			if (item.fullypaid == 1 || item.fullypaid == true)
				em.fullyPaidCompromiseItem(item)
			else 
				em.partiallyPaidCompromiseItem(item)
		}

		postRequiredPaymentCredit(receipt)		
		updateCompromiseAmountPaid(compromise, pmt)
	} 

	void updateCompromiseAmountPaid(compromise, pmt){
		def compromiseparam = [objid:compromise.objid, amtpaid:pmt.amount]
		em.updateCompromiseAmountPaid(compromiseparam)
	}

	@ProxyMethod
	public def postCapturedCurrentYearPayment(compromise, pmt){
		def receipt = createCapturedReceipt(compromise, pmt)
		receipt.remarks = 'Current year payment'
		postRequiredPaymentCredit(receipt)		

		if (pmt.type == 'cypayment' && compromise.endyear < pmt.cy){
			em.updateLastYearQtrPaid([
				objid		: compromise.rptledgerid, 
				lastyearpaid: pmt.cy,
				lastqtrpaid : 4,
			])
		}
	}


	def createCredit(receipt, installment){
		def remarks = 'Payment for Installment No. ' + installment.installmentno 
		if (installment.partial == 1)
			remarks = 'Partial ' + remarks 
		return [
			objid 			: 'CC' + new java.rmi.server.UID(),
			rptcompromiseid : installment.rptcompromiseid,
			rptreceiptid 	: receipt.objid,
			installmentid 	: installment.objid, 
			collector 		: receipt.collector,
			orno 			: receipt.receiptno,
			ordate 			: receipt.receiptdate,
			oramount 		: receipt.amount,
			amount 			: installment.amtdue, 
			mode 			: 'ONLINE',
			paidby 			: receipt.paidby,
			paidbyaddress   : receipt.paidbyaddress,
			partial 		: (installment.partial == 1 ? 1 : 0),
			remarks 		: remarks 
		]
	}


	def postRequiredPaymentCredit(receipt){
		def credit = [
			objid 			: 'CC' + new java.rmi.server.UID(),
			rptcompromiseid : receipt.compromise.objid,
			rptreceiptid 	: receipt.objid,
			installmentid 	: null, 
			collector 		: receipt.collector,
			orno 			: receipt.receiptno,
			ordate 			: receipt.receiptdate,
			oramount 		: receipt.amount,
			amount 			: receipt.amount, 
			mode 			: (receipt.mode ? receipt.mode : 'ONLINE'),
			paidby 			: receipt.paidby,
			paidbyaddress   : receipt.paidbyaddress,
			partial 		: 0,
			remarks 		: receipt.remarks,
		]
		em.create(credit, 'rptcompromise_credit')
	}


	@ProxyMethod
	public def getCurrentYearTaxes(receipt) {
		def bill = billingSvc.initBill(receipt.compromise.rptledgerid)
		bill.billdate =  dtSvc.parse('yyyy-MM-dd', receipt.receiptdate )
		def rptledger = em.findLedgerById([objid:bill.rptledgerid])
		rptledger.items = em.getCurrentYearTaxes([rptledgerid:receipt.compromise.rptledgerid])
		receipt.paiditems = rptledger.items
		def r = [:]
		r.bill = bill 
		r.rptitems = [rptledger]
		billingSvc.buildShares(r)
		return  bill.taxes 
	}

	void buildShares( receipt ) {
		def bill = billingSvc.initBill(receipt.compromise.rptledgerid)
		bill.billdate =  dtSvc.parse('yyyy-MM-dd', receipt.receiptdate )
		def rptledger = em.findLedgerById([objid:bill.rptledgerid])
		rptledger.items = receipt.paiditems 

		def r = [:]
		r.bill = bill 
		r.rptitems = [rptledger]
		billingSvc.buildShares(r)
		receipt.taxes = bill.taxes 
		bill.remove('taxes')
	}

}