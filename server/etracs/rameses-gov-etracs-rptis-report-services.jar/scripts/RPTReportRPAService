import com.rameses.annotations.*
import com.rameses.common.*;
import com.rameses.services.extended.*;

class RPTReportRPAService
{
	@Env 
	def env 

    @ActiveDB('rptreport_rpa')
    def em

    @Service('Var')
    def var 

    @Service('LGUService')
    def lguSvc 

    @DataContext('propertyclassification')
    def propertyclassification

    @DataContext('exemptiontype')
    def exemptiontype

    @Service('RPTUtil')
    def util

    @Service('ReportParameterService')
    def paramSvc 

    @Service('DateService')
    def dtSvc 

    @Service('NumberService')
    def numSvc 


    @Async
	@ProxyMethod
	public Map generateReportOnRPA( params ) {
		params.lguid = params.lgu?.objid 
		def title = 'REPORT ON REAL PROPERTY ASSESSMENTS'
		if ('period'.equalsIgnoreCase(params.reporttype.type)){
			util.buildReportTitlePeriod(title, params)
			util.buildEndingPeriodFilter(params)
		}
		else {
			params.filter = ' f.dtapproved <= $P{asofdate} '
			params.title = title 
			params.period = 'As of ' + dtSvc.format('MMMMM dd, yyyy', dtSvc.parse('yyyy-MM-dd', params.asofdate))
		}

		if (params.barangay){
			params.filter += ' AND rp.barangayid = $P{barangayid} ' 
			params.barangayid = params.barangay.objid 
		}

		if (params.classification){
			params.filter += ' AND r.classification_objid = $P{classid} '
			params.classid = params.classification.objid 
		}

		params.lguid = params.lgu?.objid 

		def taxables = em.getReportOnRPATaxable(params).each{ 
			it.rpucount = util.toInteger2( it.rpucount, 0)
			it.basictax = numSvc.round((it.totalav - it.totalrestrictionav) * params.basicrate / 100.0)
			it.seftax = numSvc.round((it.totalav - it.totalrestrictionav) * params.sefrate / 100.0)
		}
		
		int lineno = 1
		int charindex = 'a' 
		def taxableclasses = getClassifications()
		def firstspecial = taxableclasses.find{ it.special == 1 }
		taxableclasses.add( taxableclasses.indexOf( firstspecial), [objid:'SPECIAL', name:'SPECIAL', special:0] )
		
		taxableclasses.each{ item ->
			def taxable = taxables.find{ it.classid == item.objid }
			if( taxable ) {
				item.putAll( taxable )
			}
			item.taxability = 'TAXABLE' 
			if( item.special == 0 ) {
				item.classname = lineno + '. ' + item.name 
				lineno += 1
			}
			else {
				item.classname = '   ' + ((char)charindex) + '. ' + item.name 
				charindex += 1;
			}
		}
		
		def exempts  = em.getReportOnRPAExempt(params).each{ 
			it.rpucount = util.toInteger2( it.rpucount, 0)
			it.basictax = numSvc.round((it.totalav - it.totalrestrictionav) * params.basicrate / 100.0)
			it.seftax = numSvc.round((it.totalav - it.totalrestrictionav) * params.sefrate / 100.0)
		}
		
		lineno = 1 
		def exemptclasses  = getExemptionTypes();
		exemptclasses.each { item -> 
			def exempt = exempts.find{ it.classid == item.objid }
			if( exempt ) {
				item.putAll( exempt )
			}
			item.classname = lineno + '. ' + item.name 
			item.taxability = 'EXEMPT'
			lineno += 1
		}

		def p = [
			PERIOD 		: params.period,
			PERIODTYPE 	: params.periodtype,
			TITLE 		: params.title,
			FORLGUNAME  : (params.lgu ? params.lgu.name : (env.ORGCLASS + ' OF ' + env.ORGNAME)),
			LGUTYPE     : (params.lgu ? params.lgu.lgutype : env.ORGCLASS), 
			BRGYCOUNT   : getBarangays(params).size(),
			BARANGAY    : params.barangay?.name,
			BASICRATE   : params.basicrate, 
			SEFRATE     : params.sefrate, 
		]
		
		return [
			parameters  : p, 
			reportdata  : taxableclasses + exemptclasses,
		]
	}


    @ProxyMethod
    public def getClassifications(){
    	return 	propertyclassification.find([state:'APPROVED']).orderBy('orderno').list()
    }

    @ProxyMethod
    public def getExemptionTypes(  ) {
    	return 	exemptiontype.find([state:'APPROVED']).orderBy('orderno').list()
    }

    @ProxyMethod
    public def getBarangays(params){
    	return lguSvc.lookupBarangaysByRootId(params.lguid)	
    }
}
