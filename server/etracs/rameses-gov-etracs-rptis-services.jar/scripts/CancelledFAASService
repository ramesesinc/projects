import com.rameses.annotations.*
import com.rameses.common.*;
import com.rameses.services.extended.*;

class CancelledFAASService
{
	@ActiveDB('cancelledfaas')
    def em
    
	@Env
	def env
	
	@Service('TxnRefService')
    def txnRef

    @Service('DateService')
    def dateSvc

    @Service('SequenceService')
    def seqSvc

    @Service('RPTUtil')
    def util 
    
    @DataContext('cancelfaasreason')
    def em_cancelfaasreason

    @DataContext('rptledger')
    def em_rptledger

    @DataContext('rptledger_faas')
    def em_rptledger_faas

    @Service('FAASService')
    def faasSvc 

    @DataContext('faas_list')
    def faaslistDb


    def STATE_DRAFT 		= 'DRAFT'
    def STATE_FORAPPROVAL 	= 'FORAPPROVAL'
    def STATE_APPROVED 		= 'APPROVED'
    
    def SCHEMA_NAME = 'cancelledfaas'
	def SCHEMA_SIGNATORY = 'signatory'
    

	@ProxyMethod
    public def getList( params ) {
    	params.searchtext = (params.searchtext ? params.searchtext : '') + '%'
        def filters = [
            ' and f.tdno LIKE $P{searchtext}',
            ' and f.owner_name LIKE $P{searchtext}',
            ' and r.fullpin LIKE $P{searchtext}',
        ]
        return util.getListFromQuery( 'cancelledfaas:getList' , filters, params, 'cf.objid' )
    }

    @ProxyMethod
    public def initCancelledFaas(entity){
        createCancelledFaas(entity)
        return entity
    }

    @ProxyMethod
    public def createCancelledFaas(entity){
        txnRef.checkReference(entity.faas.objid)
        validateFaas(entity.faas)
        entity.faasid = entity.faas.objid 
        if (!entity.lguid)
            entity.lguid = entity.faas.lguid 
        if (!entity.originlguid)
            entity.originlguid = env.ORGID 
        if (!entity.txnno)
            entity.txnno = getNextSeries(entity)
        if (!entity.txndate)
            entity.txndate = dateSvc.serverDate
        txnRef.insertRef( entity.faas.objid, entity.objid, 'FAAS is currently referenced by Cancellation No. ' + entity.txnno + '.')
        if (!entity.state ) 
            entity.state = STATE_DRAFT
        em.create(entity)
        saveSignatory(entity)
        return entity
    }


    @ProxyMethod
    public def updateCancelledFaas( entity) {
        def old = openCancelledFaas(entity)
        if (old.state == STATE_APPROVED ) 
            throw new Exception('Document has already been approved.')
        em.update(entity)
        return entity 
    }


    @ProxyMethod
    public def deleteCancelledFaas( entity ) {
        txnRef.delete(entity.objid)
        em.deleteSignatories(entity)
        em.deleteRequirements(entity)
        em.deleteTasks(entity)
        em.delete(entity)
        return entity 
    }


    @ProxyMethod
    public def openCancelledFaas( entity ) {
        entity = em.findById(entity)
        if (!entity)
            throw new Exception('Record does not exist or has already been deleted.')
        return entity 
    }


    @ProxyMethod
    public def submitForApproval(entity){
        entity.state = STATE_FORAPPROVAL
        updateCancelledFaas(entity)
        return entity 
    }


    @ProxyMethod
    public def disapproveFaasCancellation( entity ) {
        entity.state = STATE_DRAFT
        updateCancelledFaas(entity)
        return entity 
    }


    @ProxyMethod
    public def approveFaasCancellation( entity ) {
        entity.state = STATE_APPROVED
        updateCancelledFaas(entity) 
        cancelFaas(entity)
        postLedgerCancellation(entity)
        txnRef.delete(entity.objid)
        return entity 
    }

    @ProxyMethod
    public def approveFaasCancellationByProvince( entity ) {
        return approveFaasCancellation(entity)
    }


    @ProxyMethod
    public def getCancelReasons(  ) {
        return em_cancelfaasreason.find([state:'APPROVED']).orderBy('code').list()
    }


    @ProxyMethod
    public void updateSignatoryInfo(task) {
        if (task.state.matches('assign.*') || env.action?.matches('return.*'))
            return 
        if (!task.state.matches('taxmapper|taxmapper_chief|appraiser|appraiser_chief|provrecommender|recommender|approver|provtaxmapper|provtaxmapperchief|provappraiser|provappraiserchief'))
            return

        def state = task.state.replaceAll('_', '') 

        def updatefields = '';
        updatefields += state + '_taskid = $P{' + state + '_taskid},'
        updatefields += state + '_objid = $P{' + state + '_objid},'
        updatefields += state + '_name = $P{' + state + '_name},'
        updatefields += state + '_title = $P{' + state + '_title},'
        updatefields += state + '_dtsigned = $P{' + state + '_dtsigned}'

        def params = [
            objid                   : task.refid,
            (state + '_taskid')     : task.objid,
            (state + '_objid')      : task.actor.objid,
            (state + '_name')       : task.actor.name,
            (state + '_title')      : task.actor.title,
            (state + '_dtsigned')   : task.enddate,
            updatefields            : updatefields,
        ]
        em.updateSignatoryInfo(params)
    }    

    @ProxyMethod
    public void saveSignatory( signatory ) {
        if (signatory)
            em.save(signatory, SCHEMA_SIGNATORY)
    }


    @ProxyMethod
    public def buildReportData(entity){
        entity = openCancelledFaas(entity)
        def signatory = em.read(entity, SCHEMA_SIGNATORY)
        if (signatory){
            entity.putAll(signatory)
        }

        if ('province'.equalsIgnoreCase(env.ORGCLASS))
            entity.salutation = 'To the Municipal Treasurer'
        else if ('municipality'.equalsIgnoreCase(env.ORGCLASS))
            entity.salutation = 'To the Provincial Treasurer'
        else 
            entity.salutation = 'To the City Treasurer'

        entity.location = 'Barangay ' + entity.barangay 

        def parentlgu = em.findParetLguByBarangayId(entity)
        if(parentlgu){
            if (parentlgu.iscity == 1){
                entity.location += ', City of ' + parentlgu.cityprov
            }
            else {
                entity.location += ', Municipality of ' + parentlgu.munidistrict 
                entity.location += ', ' + parentlgu.cityprov 
            }
        }

        if (!entity.approver || !entity.approver.dtsigned){
            entity.approver = [dtsigned:entity.txndate]
        }

        return entity 
    }


    void validateFaas(faas){
        //validate state 
        def state = faasSvc.getState(faas.objid)
        if ( state == 'CANCELLED') throw new Exception('FAAS has already been cancelled.')
        if ( state != 'CURRENT') throw new Exception('FAAS is not yet approved. Only current record is allowed.')

        //if land check that all improvements are cancelled
        if (faas.rputype == 'land'){
            def improvements = em.getNonCancelledImprovements([realpropertyid:faas.realpropertyid])

            if (improvements.size() == 1) {
                throw new Exception('Improvement with TD No. ' + improvements[0].tdno + ' is not yet cancelled. Cancel this improvement first before cancelling this land.')
            }
            else if( improvements.size() > 1 ){
                def tdnos = improvements.tdno.join(', ')
                throw new Exception('Improvements with TD No(s). ' + tdnos + ' are not yet cancelled. Cancel these improvements first before cancelling this land.')
            }
        }
    }

    void cancelFaas(entity){
        if (!entity.dtapproved)
            entity.dtapproved = dateSvc.serverDate
        def pdate = dateSvc.parseDate(entity.dtapproved, null)

        def faas = entity.faas 

        def cancelledbytdnos = 'Cancellation No. ' + entity.txnno
        if (entity.cancelledbytdnos){
            cancelledbytdnos = entity.cancelledbytdnos
        }

        def cancelinfo = [
            objid : faas.objid,
            state  : 'CANCELLED',
            cancelreason : entity.reason.code,
            cancelledbytdnos : cancelledbytdnos,
            canceldate   : pdate.date, 
            cancelledyear : pdate.year, 
            cancelledqtr  : pdate.qtr,
            cancelledmonth : pdate.month,
            cancelledday : pdate.day 
        ] 

        em.cancelFaas(cancelinfo)
        em.cancelRpu([objid:faas.rpuid])
        if (faas.rputype == 'land'){
            em.cancelRealProperty([objid:faas.realpropertyid])
        }

        faaslistDb.update(cancelinfo)
    }

    def getNextSeries(entity){
        def lguid =  entity.lguid.replaceAll('-','')
        def key = 'CANCELLEDFAAS-' + lguid 
        return lguid + seqSvc.getNextFormattedSeries(key)
    }

    /*========================================
    * Rules:
    *   - cancel the ledger if fullypaid as of txndate
    *   - terminate the corresponding ledger faas history set toyear = year(txndate) and toqtr = 4 
    =========================================*/
    void postLedgerCancellation(entity){
        def txnyear = dateSvc.getYear(dateSvc.parse('yyyy-MM-dd', entity.txndate))
        def ledger = em_rptledger.select('objid,lastyearpaid,lastqtrpaid').find([faasid:entity.faas.objid]).first()
        if (!ledger) 
            return 

        //check if fully paid then cancel
        if (ledger.lastyearpaid > txnyear || (ledger.lastyearpaid == txnyear && ledger.lastqtrpaid == 4)){
            em_rptledger.find([objid:ledger.objid]).update([state:'CANCELLED'])
        }

        //terminate toyear and toqtr 
        def lf = em_rptledger_faas.select('objid').find([rptledgerid:ledger.objid, toyear:0]).first()
        if (lf){
            em_rptledger_faas.find([objid:lf.objid]).update([toyear:txnyear, toqtr:4])
        }
    }
}

