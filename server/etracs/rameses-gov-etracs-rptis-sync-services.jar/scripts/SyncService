import com.rameses.annotations.*
import com.rameses.common.*;
import com.rameses.services.extended.*;

class SyncService {
	@Service()
	def self 

	@Service(value='SyncCoordinatorService', connection='coordinator-script-service')
    def coordinator 

    @Service('DateService')
    def dtSvc 

	@DataContext('sync_data')
	def em_sync

	@DataContext('sync_data_forprocess')
	def em_sync_forprocess

	@DataContext('sync_data_pending')
	def em_sync_pending


	@ProxyMethod
	public void sendAsyncData(syncdata){
		try {
			self.asyncSend(syncdata)
			completed(syncdata)
		}
		catch(e){
			moveToPending(syncdata, e)
		}
	}


	/*-------------------------------------
	*
	* Intercepted by implementors to build 
	* the actual data to send to remote 
	*
	--------------------------------------*/
	@ProxyMethod
	public def asyncSend(syncdata){
		return syncdata
	}

	/*-------------------------------------
	*
	* directly send data to coordinator
	*
	--------------------------------------*/
	@ProxyMethod
	public def send(syncdata){
		return coordinator.send(syncdata)
	}


	/*-------------------------------------
	*
	* to be intercepted by receivers
	* use args[0] to access actual data
	--------------------------------------*/
	@ProxyMethod
	public def receive(syncdata){
		//can be overriden by interceptor to
		//return specific data 
		return [:]
	}


	@ProxyMethod
	public def create(data) {
		em_sync.create(data)
		em_sync_forprocess.create(data)
		return data 
	}

	@ProxyMethod
	public def getForProcessItems(){
		return em_sync.where('forprocess.objid is not null')
				.orderBy('dtfiled')
				.limit(20)
				.list()
	}

	@ProxyMethod
	public def getPendingItems(syncdata){
		def filter = 'pending.objid is not null'

		if (syncdata.orgid) {
			filter = 'orgid = :orgid and pending.objid is not null'
		}

		return em_sync.where(filter, syncdata)
				.orderBy('dtfiled')
				.limit(20)
				.list()
	}

	@ProxyMethod
	public void movePendingToForProcess(){
		def pendings = em_sync.where('pending.objid is not null and expirydate <= :currdate', [currdate: dtSvc.serverDate])
				.orderBy('dtfiled')
				.limit(20)
				.list()

		pendings.each{
			em_sync_forprocess.create(it)
			em_sync_pending.delete(it)
		}
	}


	void completed(data){
		em_sync_forprocess.delete(data)
	}

	void moveToPending(syncdata, err){
		syncdata.error = err.message 
		syncdata.expirydate = dtSvc.add(dtSvc.serverDate, '1m')
		em_sync_pending.create(syncdata)
		em_sync_forprocess.delete(syncdata)
		println 'SyncService [ERROR] : ' + err.message 
	}
}

