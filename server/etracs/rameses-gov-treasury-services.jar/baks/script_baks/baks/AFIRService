import com.rameses.annotations.*;
import com.rameses.util.*;
import java.rmi.server.*;
import com.rameses.services.extended.*;

class AFIRService  {

	@DataContext("af_control")
	def afControl;

	@DataContext("af_control_detail")
	def afControlDetail;

	@DataContext("afir")
	def afir;

	@DataContext("afiritem")
	def afirItem;

	@Service("DateService")
	def dateSvc;

	@Service("AFControlDetailService")
	def afControlDetailSvc;

	@Env
	def env;

	def formatSeries(vv,  len) {
		return  vv.toString().padLeft( len, '0');
	}

	@ProxyMethod
	public void addNewBatch( def o ) { 
		def txndate = dateSvc.getServerDate();
		def afi = afirItem.where( "parentid = :refid AND  item.objid =:afid AND unit=:unit", o ).select("objid,qtyserved,qty").first();

		if( (afi.qtyserved + o.qty) > afi.qty )
			throw new Exception("qty specified must not exceed the unserved qty");

		def  z = afControlDetail.select( "batchno:{MAX( parent.batchno )}" ).find( [ refid: o.refid ] ).groupBy( "refid" ).first();

		int batchno = 1;
		if( z ) {
			batchno = z.batchno + 1;
		}
		
		def afunit = o.afunit;

		int len = (afunit.serieslength ? afunit.serieslength : 10);	
		int stubno = o.startstub; 
 		int starter = (o.startseries ? Integer.parseInt( o.startseries ) : 0);
		def afid = o.afid;
		(1..o.qty).each { 
			def m = [:];
			m.afid = o.afid;
			m.txnmode = 'ONLINE';
			m.state = 'DRAFT';
			m.unit = o.unit;
			if( afunit.formtype == 'serial' ) {				
				m.startseries = formatSeries( starter, len  );
				m.currentseries = m.startseries;
				m.endseries = formatSeries( starter + afunit.qty - 1, len );
				starter += afunit.qty ;
			} else {
				m.startseries = 1;
				m.endseries = afunit.qty; 
				m.currentseries = m.startseries; 
			} 
			m.dtfiled = o.refdate;
			m.stubno = stubno++;
			m.active = 0;
			m.prefix = o.prefix;
			m.suffix = o.suffix;
			m.batchno = batchno;
			m.currentindexno = 1;
			m.respcenter = o.respcenter; 
			m.cost = o.cost;
			m = afControl.create(m);

			def mode = (o.reftype == 'PURCHASE_RECEIPT') ? 'received' : 'begin';
			def remarks = (o.reftype == 'PURCHASE_RECEIPT') ? 'RECEIPT OF PURCHASE' : 'BEGIN BALANCE';
			afControlDetailSvc.addDetail( o, [:], m.objid, txndate, m.currentseries, m.endseries, mode, remarks );
		} 
		afirItem.find( [objid: afi.objid] ).update( [qtyserved: "{qtyserved + :qty}"], [qty: o.qty] );
	}


	def buildIdString ( ids ) { 
		def buff = new StringBuilder();
		int b = 0;
		buff.append("(");
		ids.each {
			if(b==0) {
				b=1;
			}
			else {
				buff.append(",");
			}
			buff.append( "'" + it.controlid + "'"); 
		}
		buff.append(")");
		return buff.toString();
	};

	//this is called by the main AFRI ebtry screen
	@ProxyMethod
	public void removeBatchEntry( def o ) {
		def ids = afControlDetail.find([refid: o.refid ]).where("parent.afid = :afid AND parent.batchno = :batchno AND parent.unit= :unit", o ).select("controlid").list();
		def qty = ids.size();
		def strList = buildIdString( ids );
		afControlDetail.where( "controlid IN " + strList ).delete();

		if( o.txntype.matches('PURCHASE_RECEIPT|BEGIN_BALANCE' )) {
			afControl.where( "objid IN " + strList ).delete();	
			//update the batchno of remaining af control
			ids = afControlDetail.find( [refid: o.refid]  ).where( "parent.batchno > :batchno", o ).select("controlid").list();
			if( ids ) {
				strList = buildIdString( ids );
				afControl.where( "objid IN " + strList ).update( [batchno: "{batchno - 1}"] );		
			}
		}
		else if( o.txntype == 'ISSUE') {
			afControl.where( "objid IN " + strList ).update([state:'OPEN']);	
		}
		afirItem.find( [parentid: o.refid] ).where("item.objid =:afid AND unit =:unit", o).update( [qtyserved: "{qtyserved - :qty}"], [qty: qty] ); 
	}


	@ProxyMethod
	public void issue( def o ) { 
		def txndate = dateSvc.getServerDate();
		def afi = afirItem.where( "parentid = :refid AND  item.objid =:afid AND unit=:unit", o ).select("objid,qtyserved,qty,txntype").first();

		int qty = afi.qty - afi.qtyserved;
		def remarks = afi.txntype;
		def sbuff = new StringBuilder();
		sbuff.append( "state = 'OPEN' AND afid =:afid AND unit =:unit" );
		if( o.respcenter?.objid ) {
			sbuff.append(  " AND respcenter.objid =:respcenterid " );
			o.respcenterid = o.respcenter.objid;
		}

		def list = afControl.select('objid,startseries,currentseries,endseries').where( sbuff.toString(), o).orderBy('dtfiled,batchno,stubno').limit( qty ).list();
		if(!list)
			throw new Exception("No available stock for " + o.afid + " " + o.unit);		
		list.each {
			afControlDetailSvc.addDetail( o, [:], it.objid, txndate, it.currentseries, it.endseries, 'issue', remarks );
			afControl.find([objid: it.objid]).update([state:'PROCESSING']);
		}
		afirItem.find([objid: afi.objid]).update( [qtyserved: '{qtyserved + :qty}'], [qty: list.size() ] );
	}	


    @ProxyMethod
	public def post( def o ) {
		def ar = afir.find([ objid: o.objid ]).first();
		def zlist = afirItem.find( [parentid: o.objid] ).list();
		zlist.each {
			def txntype = it.txntype;
			def afid = it.item.objid;
			def unit = it.unit;
			if(it.qtyserved > it.qty ) 
				throw new Exception("Qty served must be less than or equal to qty for " + afid + " " + unit );
			
			def ids = afControlDetail.find( [refid: o.objid]  ).where("parent.afid = :afid AND parent.unit =:unit", [afid: afid, unit:unit]).select("controlid").list();
			if(!ids) throw new Exception("There are no control ids found");
			def strList = buildIdString( ids );
			def state = null;
			if( txntype.matches('PURCHASE|BEGIN') ) {
				state = 'OPEN';
			}
			else if( txntype.matches('COLLECTION|FORWARD')) {
				state = 'ISSUED'
			}
			else if( txntype == 'SALE') {
				state = 'SOLD';
			}
			else {
				throw new Exception("No state for AFIR Item Txntype " + txntype );	
			}
			def u = [:];
			u.state = state;
			u.respcenter = ar.respcenter;
			if( ar.issueto?.objid ) {
				u.owner = ar.issueto;
				u.assignee = ar.issueto;
			}
			afControl.where( "objid IN " + strList ).update( u );
		}
		afControlDetail.find( [ refid: o.objid ] ).update( [state: 1 ] );
		afir.find([ objid: o.objid ]).update([state: 'POSTED']);
	}

}
