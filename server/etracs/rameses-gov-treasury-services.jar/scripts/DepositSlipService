import com.rameses.annotations.*;
import com.rameses.util.*;
import java.rmi.server.*;

class DepositSlipService  {

	@DataContext("depositslip")
	def depositSlipEm;

	@DataContext("paymentcheck")
	def paymentCheckEm;

	@DataContext("depositvoucher_fund")
	def dvFundEm;

	@ProxyMethod
	public def updateCheckTotal( def o ) {
		if(!o.items) throw new Exception( "items is required");
		if(!o.depositslipid) throw new Exception( "depositslipid is required");
		o.items.each {
			paymentCheckEm.find([ objid:it.objid ]).update( [depositslipid: o.depositslipid ] );
		}
		def z = [ depositslipid: o.depositslipid ];
		depositSlipEm.updateCheckTotal( z );
		depositSlipEm.cleanUpNullTotals( z );
		def c = depositSlipEm.find( [objid: o.depositslipid ]).first();
		depositSlipEm.updateFundCheckTotals( [ depositvoucherid: c.depositvoucherid , fundid: c.fundid ] );
		return c;
	}

	@ProxyMethod
	public def removeCheck( def o ) {
		if(!o.items) throw new Exception( "items is required");
		if(!o.depositslipid) throw new Exception( "depositslipid is required");
		o.items.each {
			paymentCheckEm.find([ objid:it.objid ]).update( [depositslipid: "{NULL}" ] );
		}
		def z = [ depositslipid: o.depositslipid ];
		depositSlipEm.updateCheckTotal( z );
		depositSlipEm.cleanUpNullTotals( z );
		def c = depositSlipEm.find( [objid: o.depositslipid ]).first();
		depositSlipEm.updateFundCheckTotals( [ depositvoucherid: c.depositvoucherid , fundid: c.fundid ] );
		return c;
	}

	@ProxyMethod
	public void updateCash( def o ) {
		if(!o.depositslipid) throw new Exception( "depositslipid is required");
		if(!o.containsKey('totalcash')) throw new Exception( "totalcash is required");
		if(!o.cashbreakdown) throw new Exception( "cash breakdown is required");

		def u = [totalcash: o.totalcash, cashbreakdown: o.cashbreakdown ];
		depositSlipEm.find( [objid: o.depositslipid ]).update( u );
		def c = depositSlipEm.find( [objid: o.depositslipid ]).first();
		depositSlipEm.updateFundCashTotals( [ depositvoucherid: c.depositvoucherid , fundid: c.fundid ] );
	}

	@ProxyMethod
	public void removeDepositSlip( def o ) {
		def c = depositSlipEm.find( [objid: o.objid ]).first();
		depositSlipEm.find([objid: c.objid]).delete();
		depositSlipEm.updateFundCheckTotals( [ depositvoucherid: c.depositvoucherid , fundid: c.fundid ] );
		depositSlipEm.updateFundCashTotals( [ depositvoucherid: c.depositvoucherid , fundid: c.fundid ] );
		depositSlipEm.cleanUpNullFundTotals( [ depositvoucherid: c.depositvoucherid , fundid: c.fundid ] )
	}

	@ProxyMethod
	public void approve( def o ) {
		def ds = depositSlipEm.find([objid: o.objid]).first();
		if( (ds.totalcash + ds.totalcheck) != ds.amount )
			throw new Exception("Total cash and total check must equal the total amount");

		def db = dvFundEm.find( [parentid: ds.depositvoucherid, fundid: ds.fundid ] ).first();
		if(!db) throw new Exception("Depositvoucher fund not found for this deposit slip");
		if( db.totalcash > db.cashtodeposit ) throw new Exception("Total cash to deposit must not be greater than cash to deposit");
		if( db.totalcheck > db.checktodeposit ) throw new Exception("Total check to deposit must not be greater than checks to deposit");
			
		depositSlipEm.find([objid: o.objid]).update( [state: 'APPROVED' ]);
	}

	@ProxyMethod
	public void disapprove( def o ) {
		depositSlipEm.find([objid: o.objid]).update( [state: 'DRAFT' ]);
	}

	@ProxyMethod
	public void validate( def o ) {
		if(!o.objid) throw new Exception( "objid is required");
		if(!o.validation) throw new Exception( "validation is required");

		def ds = depositSlipEm.find( [objid: o.objid]).first();

		def db = dvFundEm.find( [parentid: ds.depositvoucherid, fundid: ds.fundid ] ).first();
		if(!db) throw new Exception("Depositvoucher fund not found for this deposit slip");

		if( db.totalcash != db.cashtodeposit ) throw new Exception("Total cash to deposit must be equal to total cash deposited");
		if( db.totalcheck != db.checktodeposit ) throw new Exception("Total check to deposit must be equal to total check deposited");

		depositSlipEm.find([objid: o.objid]).update( [state: 'VALIDATED', validation: o.validation ]);
	}

}
