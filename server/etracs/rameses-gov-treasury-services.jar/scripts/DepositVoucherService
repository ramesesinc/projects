import com.rameses.annotations.*;
import com.rameses.util.*;
import java.rmi.server.*;

class DepositVoucherService  {

	@Env
	def env;

	@Service("DateService")
	def dateSvc;

	@Service("SequenceService")
	def seqSvc;

	@Service('ControlService') 
	def controlSvc;	

	@Service("Var")
	def var;			

	@DataContext("collectionvoucher")
	def cvEm;

	@DataContext("depositvoucher")
	def depositEm;

	@DataContext("paymentcheck")
	def paymentCheckEm;

	@DataContext("depositvoucher_fund")
	def depositFundEm;

	@DataContext("depositslip")
	def depositSlipEm;

	@ProxyMethod
	public def create( def o ) {
		if(!o.items)
			throw new Exception("Please select at least one item " + o.amount );
		/*
	    UPDATED TABLES :
	        depositvoucher, collection, deposit_fund, collection_fund, paymentcheck
		*/
		def m = [:];
		m.state = "OPEN"
		m.controlno = 'TMP-DEP-'+env.USERID;
		m.controldate = dateSvc.getBasicServerDate(); 
		m.amount = o.items.sum{ it.amount };
		m.createdby = [objid:env.USERID,  name:env.FULLNAME];
		m.dtcreated = dateSvc.getServerDate();	
		m = depositEm.create( m );

		cvEm.where( ''' objid IN (${ids}) ''' ).vars( "ids",  "'" + o.items*.objid.join("','") + "'" ).update( [depositvoucherid: m.objid ] );
		def z = [ depositvoucherid: m.objid ];
		depositEm.insertDepositFund( z );
		depositEm.updatePaymentCheckDepositId( z );
		depositEm.updatePaymentCheckDefaultFund( z );
		depositEm.updateFundCheckTotal( z );
		depositEm.cleanUpNullTotals( z );
		return m;
	}


	@ProxyMethod
	public void updateCheckToDeposit( def o ) {
		if(!o.items) throw new Exception( "items is required");
		if(!o.fundid) throw new Exception( "fundid is required");
		if(!o.depositvoucherid) throw new Exception( "depositvoucherid is required");
		o.items.each {
			paymentCheckEm.find([ objid:it.objid ]).update( [fundid: o.fundid] );
		}
		def z = [ depositvoucherid: o.depositvoucherid ];
		depositEm.updateFundCheckTotal( z );
		depositEm.cleanUpNullTotals( z );
	}

	@ProxyMethod
	public void updateCashToDeposit( def o ) {
		if(!o.fundid) throw new Exception( "fundid is required");
		if(!o.depositvoucherid) throw new Exception( "depositvoucherid is required");
		if(!o.containsKey('totalcash')) throw new Exception( "totalcash is required");
		depositFundEm.find( [parentid: o.depositvoucherid, fundid: o.fundid ]).update( [cashtodeposit: o.totalcash ] );
	}

	@ProxyMethod
	public void assignCashier( def o ) {
		if(!o.fundid) throw new Exception( "fundid is required");
		if(!o.depositvoucherid) throw new Exception( "depositvoucherid is required");
		if(!o.containsKey('cashier') ) throw new Exception( "cashier is required");
		depositFundEm.find( [parentid: o.depositvoucherid, fundid: o.fundid ]).update( [cashier: o.cashier ] );
	}

	

	@ProxyMethod
	public def submitForDeposit( def o ) {
		if(!o.objid) throw new Exception( "objid is required");

		//ensure there are no check payments unassigned
		def z = paymentCheckEm.find( [depositvoucherid: o.objid ]).where( " fundid IS NULL ").first();
		if( z ) throw new Exception("All checks associated with this voucher must be assigned to a fund to deposit");

		z = depositFundEm.find( [parentid: o.objid ]).select("objid").where( "( amount - (cashtodeposit+checktodeposit)) <> 0").first();
		if( z ) throw new Exception( "All amount must equal checks and cash to deposit" );

		z = depositFundEm.find( [parentid: o.objid ]).select("objid").where( " cashier.objid IS NULL ").first();
		if( z ) throw new Exception( "All funds must be assigned to a cashier");


		def m =  [state: 'FOR_DEPOSIT'];
		m.dtposted = dateSvc.getServerDate(); 

		def txncode = [ "DEP", env.TXNCODE, env.ORGTXNCODE ].findAll{( it )}.join("-");
		m.controlno = controlSvc.formatTxnno([ txncode: txncode, txndate: m.dtposted, format: var.deposit_format, sequenceid_format: var.deposit_sequenceid_format ]); 

		depositFundEm.find([ parentid: o.objid ]).select('objid,fund.code').list().each{ 
			def txnno = m.controlno + (it.fund?.code ? ('-'+it.fund.code) : ""); 
			depositFundEm.find([ objid: it.objid ]).update([ controlno: txnno ]); 
		} 

		depositEm.find([ objid: o.objid ]).update( m );
		return m;
	}

	@ProxyMethod
	public def post( def o ) {
		if(!o.objid) throw new Exception( "objid is required");
		def z = depositFundEm.find( [parentid: o.objid ]).select("objid").where( "( amount - (totalcash+totalcheck)) <> 0").first();
		if(z) throw new Exception("Total Amount must be equal to total checks and total cash deposited");

		z = depositSlipEm.find( [depositvoucherid: o.objid ] ).where( " validation.refno IS NULL ").first();
		if(z ) throw new Exception("All deposit slips must be validated");

		def b = paymentCheckEm.find( [depositvoucherid: o.objid ]).where( "despotislipid IS NULL").first()
		if(b )
			throw new Exception("All checks referenced must be deposited");
		def m = [ state: 'POSTED' ];
		depositEm.find( [objid: o.objid ]).update( m );

		//post to jev
		def ref = [refid:p.objid,refno:p.controlno,reftype:'depositvoucher', refdate:p.controldate, txntype:'DEPOSIT'];

		def jevBatch = [:];
		jevBatch.ref = ref;
		jevBatch.funds = [];
		jevBatch.items = [];

		depositFundEm.find([ parentid: p.objid ]).select('objid,fund.*,amount').list().each{ 
			jevBatch.funds << [ objid: it.objid, refno:it.controlno, fund: it.fund, amount: it.amount  ];	 
		} 

		def pm = [depositvoucherid: p.objid ];

		jevBatch.items.addAll( depositEm.getBankAccountLedgerItems( pm ) );
		jevBatch.items.addAll( depositEm.getCashLedgerItems( pm ) );
		jevSvc.createBatch( jevBatch );

		return m; 
	} 
}
