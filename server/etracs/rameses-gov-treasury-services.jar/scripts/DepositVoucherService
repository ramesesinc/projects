import com.rameses.annotations.*;
import com.rameses.util.*;
import java.rmi.server.*;

class DepositVoucherService  {

	@DataContext("collectionvoucher")
	def cvEm;

	@DataContext("collectionvoucher_fund")
	def cvfEm;

	@DataContext("depositvoucher")
	def dvEm;

	@DataContext("depositvoucher_fund")
	def dvfEm;


	@DataContext("cashreceiptpayment_noncash")
	def ncpEm;

	@DataContext("checkpayment")
	def chkPmtEm;


	@Service("DateService")
	def dateSvc;

	@Service('ControlService') 
	def controlSvc;	

	@Service("Var")
	def var;

	@Env
	def env;

	@ProxyMethod
	public def create( def o ) {
		def txncode = [ "DV", env.TXNCODE, env.ORGTXNCODE ].findAll{( it )}.join("-");

		def m = [:];
		m.state = "OPEN";
		m.dtcreated = dateSvc.getServerDate();
		m.controldate = m.dtcreated;
		m.createdby = [objid:env.USERID, name: env.FULLNAME, title: env.JOBTITLE ];
		m.controlno = controlSvc.formatTxnno([ txncode: txncode, txndate: m.dtcreated, format: var.deposit_format, sequenceid_format: var.deposit_sequenceid_format ]); 
		m.amount = o.amount;
		m = dvEm.create( m );

		def str = "('" + o.items.join( "','") + "')";
		cvEm.where( "objid IN " + str ).update( [depositvoucherid: m.objid ] );

		//for each collection voucher fund create a deposit voucher fund
		def list = cvfEm.where( "parentid IN " + str ).groupBy("fund.objid").select( "fund.objid,totalcheck:{SUM(totalcheck)},totalcash:{SUM(totalcash)}" ).list();
		list.each {
			def dvf = [:];
			dvf.parentid = m.objid;
			dvf.parent = [objid: m.objid];
			dvf.fundid = it.fund.objid;
			dvf.fund = [objid:it.fund.objid ];
			dvf.amount = ( it.totalcash + it.totalcheck );
			dvf.amountdeposited = 0;
			dvf.state = 'OPEN';
			dvfEm.create( dvf );
		}
		
		//retrieve check payments from the cash receipt non cash payments
		def zlist = ncpEm.where( "reftype='CHECK' AND receipt.remittance.collectionvoucherid IN " + str ).list().groupBy{it.refid};
		zlist.each { refid,v->
			def u = [depositvoucherid: m.objid];
			if( v.size() == 1 ) u.fundid = v[0].fund.objid;
			chkPmtEm.find([objid: refid]).update(u);		
		}
		//throw new Exception("stop save")
		return m;
	}

	@ProxyMethod
	public void addChecks( def o ) {
		def str = " ('" + o.list.join("','") + "')";
		chkPmtEm.where( "objid IN " + str ).update( [fundid: o.fundid ]);
	}

	@ProxyMethod
	public void removeCheck( def o ) {
		chkPmtEm.where( "objid = :objid", o ).update( [fundid: "{NULL}" ]);
	}

	/*
	@ProxyMethod
	public def post(def o ) {
		//test if there are undeposited checks
		int t = checkpaymentEm.find( [depositvoucherid: o.objid] ).where("depositslipid IS NULL").select("v:{COUNT(*)}").val();
		if(t > 0 )
			throw new Exception("All checks associated with this deposit must have deposit slips");

		//test if there are deposit slips not validated
		t = depositSlipEm.find( [depositvoucherid: o.objid] ).where("validation.refno IS NULL").select("v:{COUNT(*)}").val();
		if(t > 0 )
			throw new Exception("All deposit slips associated with this deposit must be validated");

		//test amount deposited must equal amount to deposit
		def ref = depositEm.find([objid: o.objid]).first();
		if( ref.amount != ref.amountdeposited )
			throw new Exception("Amount of deposit must equal to amount deposited");


		//create the jev and post to jev	
		def jev = [items:[]]	
		jev.fundid = ref.fundid;
		jev.state = 'OPEN'
		jev.refid = ref.objid;
		jev.refno = ref.controlno;

		jev.jevdate = ref.controldate;
		jev.reftype = "DEPOSIT";
		jev.txntype = "DEPOSIT";

		jev.postedby = [objid:env.USERID, name: env.FULLNAME, title: env.JOBTITLE ];
		jev.amount = ref.amount;

		//add all the items
		jev.items.addAll( depositEm.getBankAccountLedgerItem([depositvoucherid: o.objid] ));
		jev.items.addAll( depositEm.getCashLedgerItem([depositvoucherid: o.objid] ));

		jevSvc.create( jev );

		depositEm.find([objid: o.objid]).update([state:'POSTED']);

	}
	*/


}
