import com.rameses.annotations.*;
import com.rameses.common.*;
import com.rameses.util.*;

class RemittanceService  {

	@Env
	def env;

	@Service 
	def self; 

	@Service('PersistenceService') 
	def persistSvc; 

	@Service('ControlService') 
	def controlSvc;

	@Service("DateService")
	def dateSvc;

	@Service("Var")
	def var;

	@ActiveDB("remittance_tool")
	def remittance_tool; 

	@DataContext("remittance")
	def remdb;

	@DataContext("remittance_fund")
	def remf_db;

	@DataContext("remittance_af")
	def remaf_db;

	@DataContext("remittance_noncashpayment")
	def rem_noncash;

	@DataContext("af_control")
	def afc_db;

	@DataContext('cashreceipt') 
	def cashreceipt_db;

	@ActiveDB('remittance_rcd') 
	def rcd_db;

	@ProxyMethod
	public def init( param ) { 
		boolean split_txn = (var.remittance_split_transaction.toString().matches('false|0') ? false : true); 

		def temptxnno = com.rameses.util.Encoder.MD5.encode( env.USERID ); 
		def draftdata = remdb.find([ txnno: temptxnno ]).first(); 
		if ( draftdata ) throw new Exception("""  
			You still have a DRAFT remittance that was previously created.  
		""");

		boolean offlineMode = ( params.remittancedate ? true : false ); 

		def rundate = dateSvc.getServerDate(); 
		def remittanceid = "REM" + new java.rmi.server.UID(); 
		def o = [ objid: remittanceid, state:'DRAFT', txnno: temptxnno, dtposted: rundate ]; 
		o.collector = [ objid: env.USERID, name: env.FULLNAME, title: env.JOBTITLE ]; 
		o.amount = o.totalcash = 0.0; 
		o.totalcheck = o.totalcr = 0.0; 
		o.cashbreakdown = []; 

		if ( offlineMode ) { 
			o.remittancedate = params.remittancedate; 
			split_txn = false; 

		} else { 
			o.remittancedate = new java.sql.Date( rundate.time ); 
		} 

		remdb.create( o );  

		def hasPrevMonthTrxns = false; 
		def info = [ remittanceid: remittanceid, collectorid: env.USERID ];
		if ( split_txn ) {
			info.txndate = getMonthFirstDate( rundate ); 
			remdb.updateSerialReceipts( info );  
			remdb.updateNonSerialReceipts( info );  
			def test = cashreceipt_db.find([ remittanceid: remittanceid ]).first(); 
			if ( test ) { 
				o.endofmonth = true; 
				o.message = "End of the month remittance only. Please remit again for the remaining collection."; 
				o._txndate = info.txndate; 
				hasPrevMonthTrxns = true; 

				o.remittancedate = dateSvc.add( info.txndate, "-1d" );  
			} 
		} 
		
		if ( !hasPrevMonthTrxns ) {
			info.txndate = ( offlineMode ? o.remittancedate : o.dtposted ); 
			remdb.updateSerialReceipts( info ); 
			remdb.updateNonSerialReceipts( info ); 
			o._txndate = dateSvc.format('yyyy-MM-dd HH:mm:ss', info.txndate);
		} 

		o.items = remdb.getBuildReceiptSummary( info );  
		if ( !o.items ) throw new Exception("No collections to be remitted.   ");

		remdb.insertNonCashPayment( info ); 
		remdb.insertFundSummary( info ); 
		remdb.updateNonCashReceiptPayment( info ); 

		o.amount = 0.0;
		o.totalcr = 0.0;
		o.totalcash = 0.0;
		o.totalcheck = 0.0;
		remf_db.find([ remittanceid: remittanceid ]).list().each{
			o.amount += it.amount;
			o.totalcr += it.totalcr;
			o.totalcash += it.totalcash;
			o.totalcheck += it.totalcheck;
		}
		remdb.find([ objid: remittanceid ]).update([ 
			amount: o.amount, totalcash: o.totalcash, 
			totalcheck: o.totalcheck, totalcr: o.totalcr 
		]); 

		remdb.getBuildCancelSeries( info ).groupBy{ it.controlid }.each{ k,v-> 
			def afc = o.items.find{ it.controlid == k } 
			afc.cancelSeriesList = v; 
		}

		o.checks = remdb.getNonCashPayments( info );

		def afcs = afc_db.find([ owner_objid: o.collector.objid ]).where(' currentseries <= endseries ').list(); 
		afcs.each{ it.controlid=it.objid } 

		def rafparam = [ txndate: o.dtposted ]; 
		rafparam.controls = afcs.collect{ it.objid } 
		rafparam.controls.addAll( o.items.collect{ it.controlid } ); 
		rafparam.controls = rafparam.controls.unique().collect{[ controlid: it ]} 

		def rafs = self.getBuildAF( rafparam ); 
		rafs.each{ a-> 
			def b = o.items.find{ it.controlid==a.controlid } 
			if ( !b ) return; 

			if ( b.formtype=='serial' ) {
				a.qtycancelled = b.cqty;
				a.qtyissued = b.qty; 
				a.issuedendseries = b.endseries; 
				a.issuedstartseries = b.startseries; 
				a.endingstartseries = a.issuedendseries+1; 
				a.endingendseries = b.afendseries;
			} else if ( b.formtype=='cashticket' ) { 
				def currentseries = b.afstartseries;
				def qty = (int) ( b.amount / b.denomination ); 
				def cts = remdb.getRemittedCashTickets([ controlid: a.controlid ]); 
				cts = cts.findAll{ it.remittanceid != remittanceid } 
				if ( cts ) {
					currentseries = ((int) (cts.sum{( it.amount ? it.amount : 0.0 )} / b.denomination)) + b.afstartseries; 
				} 
				a.issuedstartseries = currentseries; 
				a.issuedendseries = (currentseries + qty)-1; 
				a.qtyissued = qty; 
				a.endingstartseries = a.issuedendseries+1;
				a.endingendseries = b.afendseries;
			}

			if ( a.endingstartseries > b.afendseries ) {
				a.endingstartseries = a.endingendseries = null; 
				a.qtyending = 0; 
			} else {
				a.qtyending = (a.endingendseries - a.endingstartseries)+1; 
			} 
		}

		rafs.each{ 
			it.objid = 'REMAF-'+ new java.rmi.server.UID(); 
			it.remittanceid = remittanceid; 
			remaf_db.create( it ); 
		} 
		return o; 
	} 

	@ProxyMethod 
	public def getBuildAF( afcs ) {
		return []; 
	} 

 	@ProxyMethod
    public void updateCashBreakdown( o ) { 
        def m = remf_db.find([ objid: o.objid ]).select('objid,remittanceid').first(); 
        if ( !m ) return;

        remf_db.find([ objid: m.objid ]).update([ cashbreakdown: o.cashbreakdown ]);  

		def totalcbd = summarizeFundCashbreakdown( m.remittanceid ); 
		remdb.find([ objid: m.remittanceid ]).update([ cashbreakdown: totalcbd ]);
    } 

    private def summarizeFundCashbreakdown( remittanceid ) {
        def arr = [];
        def cblist = remf_db.find([ remittanceid: remittanceid ]).select("cashbreakdown").where(" totalcash > 0 ").list();
        cblist.each { 
        	if ( it.cashbreakdown ) arr.addAll( it.cashbreakdown ); 
        }

        def newarr = [];
        arr.groupBy{ it.denomination }.each { k,v->
        	newarr << [ caption:k, denomination:k, qty: v.sum{it.qty}, amount: v.sum{it.amount} ];	
        }
        return newarr; 
    }

	@ProxyMethod
	public void validateBreakdown( def o ) {
		// check cashbreakdown per fund 
        def cblist = remf_db.find([ remittanceid: o.objid ]).select("cashbreakdown,fund.*").where(" totalcash > 0 ").list();
		cblist.each {
            if(it.totalcash >0 && ( it.cashbreakdown?.sum{c->c.amount}!=it.totalcash)  )
                throw new Exception("Cashbreakdown for "+it.fund.title + " must be exact ");
        }
	}

	@ProxyMethod 
	public def post( param ) { 
		if ( !param.remittanceid ) throw new Exception("remittanceid parameter is required"); 

		def o = remdb.find([ objid: param.remittanceid ]).first(); 
		if ( !o ) throw new Exception('Remittance record does not exist.');
		if ( o.state != 'DRAFT' ) throw new Exception("Remittance record is no longer in DRAFT mode");

		// check cashbreakdown per fund 
        def cblist = remf_db.find([ remittanceid: o.objid ]).select("totalcash,cashbreakdown,fund.*").where(" totalcash > 0 ").list();
        cblist.each { 
        	def amt = it.cashbreakdown?.sum{( it.amount ? it.amount: 0.0 )} 
        	if ( !amt ) throw new Exception('Please specify a cashbreakdown for fund '+ it.fund.title ); 

        	def diff = (it.totalcash - amt);
	        if( diff  > 0.01 )
	            throw new Exception("Cash to remit is insufficient. Please review your collection for " + it.fund.title);
	        if( diff < -0.01 )
	            throw new Exception("Please review your collection. You have over declared the cash breakdown for " + it.fund.title);
        }

		param.cashbreakdown = summarizeFundCashbreakdown( o.objid ); 

		o.state = 'OPEN'; 
		o.dtposted = dateSvc.getServerDate(); 

		def txncode = [ "REM", env.TXNCODE, env.ORGTXNCODE ].findAll{( it )}.join("-");
		o.txnno = controlSvc.formatTxnno([ txncode: txncode, txndate: o.dtposted, format: var.remittance_format, sequenceid_format: var.remittance_sequenceid_format ]); 

		if ( !o.collector ) o.collector = [:];
		if ( param.collector?.signature ) o.collector.signature = param.collector.signature; 

		remdb.find([ objid: param.remittanceid ]).update([ 
			txnno: o.txnno, state: o.state, dtposted: o.dtposted, 
			cashbreakdown: param.cashbreakdown, collector: o.collector 
		]); 
		remdb.updateFundControlNo([ remittanceid: param.remittanceid ]); 
		return o; 
	} 


    @ProxyMethod 
    public void revert( params ) {
    	if ( !params.objid ) throw new Exception('objid parameter is required'); 

    	params.remittanceid = params.objid; 
    	def o = remittance_tool.findRemittance( params ); 
    	if ( o?.liquidated > 0 ) 
    		throw new Exception('This transaction has already been liquidated. Cannot revert remittance'); 

		remittance_tool.revertCashReceiptNonCashPayments( params ); 
		remittance_tool.revertCashReceipts( params ); 

    	remittance_tool.removeFunds( params ); 
    	remittance_tool.removeAFs( params ); 
    	remittance_tool.removeCashReceipts( params ); 
    	remittance_tool.removeCreditMemoPayments( params ); 
    	remittance_tool.removeNonCashPayments( params ); 
    	remittance_tool.removeRemittance( params ); 
    } 

    @ProxyMethod
    public void approve( o ) { 
    	def m = [ state: 'APPROVED' ]; 
    	m.liquidatingofficer = [ objid:env.USERID, name:env.FULLNAME, title:env.JOBTITLE ]; 
    	if ( !m.liquidatingofficer.objid ) 
    		throw new Exception('liquidatingofficer field is required');  

    	remdb.find([ objid : o.objid ]).update( m ); 
    } 

    @ProxyMethod
    public def disapprove( params ) { 
    	def o = remdb.find([ objid : params.objid ]).first(); 
    	if ( !o ) return; 

    	if ( !o.state.toString().equalsIgnoreCase('APPROVED')) 
    		throw new Exception('This transaction is no longer in APPROVED mode');

    	o.state = 'OPEN'; 
    	o.liquidatingofficer = [:]; 
    	
		remdb.find([ objid : params.objid ]).update([ 
			liquidatingofficer : [ objid:'{NULL}', name:'{NULL}', title:'{NULL}' ], 
			state: o.state 
		]); 
		return o; 
    } 


    @ProxyMethod 
    public def openForReport( params ) {
    	if ( !params.objid ) throw new Exception('objid parameter is required');  

    	def findBy = [ objid: params.objid ]; 
    	def o = persistSvc.read([ _schemaname: 'remittance', objid: findBy.objid, findBy: findBy ]); 
    	if ( !o ) throw new Exception('Remittance record does not exist'); 

    	def m = [ remittanceid: o.objid ]; 
    	o.collectiontype = rcd_db.getReceiptForms( m ); 
    	o.collectionsummaries = rcd_db.getCollectionSummaries( m ); 

    	return o;  
    }


	private def getMonthFirstDate( dt ) {
        def cal = Calendar.getInstance();
        cal.setTime ( dt ); 
        cal.set( Calendar.DAY_OF_MONTH, 1 );
        return new java.sql.Date( cal.timeInMillis ); 
    }  
}