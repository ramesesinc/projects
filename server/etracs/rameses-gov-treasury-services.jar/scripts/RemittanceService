import com.rameses.annotations.*;
import com.rameses.util.*;

class RemittanceService  {

	@Env
	def env;

	@Service("DateService")
	def dateSvc;

	@Service("CashBreakdownSummaryService")
	def cashBreakdownSvc;

	@Service("SequenceService")
	def seqSvc;

	@DataContext("cashreceipt")
	def cashReceiptEm;

	@DataContext("remittance")
	def remEm;

	@DataContext("remittance_fund")
	def rfEm;

	@DataContext("cashreceiptpayment_noncash")
	def ncEm;

	@Service('ControlService') 
	def controlSvc;

	@Service("Var")
	def var;

	@ProxyMethod
	public def getCashReceiptForRemittance( def p ) {
		return remEm.getCashReceiptsForRemittance( p );
	}
 
	@ProxyMethod
	public def create( def pp ) {

		def o = pp.items;

		def m = [:];
		m.controlno = 'TMP-REM-'+env.USERID;
		m.controldate = dateSvc.getBasicServerDate();
		m.dtposted = dateSvc.getServerDate();
		m.state = "DRAFT";
		m.amount = 0;
		m.totalcr = 0;
		m.totalcash = 0;
		m.totalcheck = 0;
		m.cashbreakdown = [];
		m.collector = [objid:env.USERID, name: env.FULLNAME, title: env.JOBTITLE ]; 
		m = remEm.create( m );

		def scond = "collector.objid = :userid AND series BETWEEN :fromseries AND :toseries";
		o.findAll{ it.formtype == 'serial' }.each {
			//update also remittance_fund
			def p = [userid: env.USERID, fromseries: it.fromseries, toseries: it.toseries ];
			cashReceiptEm.find( [controlid: it.afcontrolid ] ).where(scond, p).update( [remittanceid: m.objid] );
			//test to be sure. compare records affected with the fromseries and toseries 
			def qty = cashReceiptEm.find( [controlid: it.afcontrolid, remittanceid: m.objid ] ).select( "x:{COUNT(*)}" ).val();
			if( qty != (it.toseries - it.fromseries + 1)) 
				throw new Exception("Mismatch qty with series. Please check the ff: " + it.fromseries + "=" + it.toseries + ". Please redo remittance" );
		}

		def z = [remittanceid: m.objid]

		//check first if there are open receipts
		def openList = remEm.getOpenChecks( z );
		if(openList ) {
			def vstr = "There are still open checks with balance unused. Please verify the ff:\n";
			vstr += openList.collect{ 'Check No ' + it.refno + ' (' + it.receivedfrom + ') ' + it.amount  }.join("\n");
			throw new Exception(vstr);
		}
		remEm.insertRemittanceFund( z );

		def clist = rfEm.find( z ).list();
		clist.each {
			def ppp = [remittanceid: it.remittanceid , fundid: it.fund.objid ];

			def u = [:];
			u.amount = it.amount;
			u.totalcheck = ncEm.select( "amount:{SUM(amount)}").where("receipt.remittanceid=:remittanceid AND fund.objid =:fundid AND reftype = 'CHECK' ", ppp ).val();
			if(!u.totalcheck) u.totalcheck = 0;

			u.totalcr = ncEm.select( "amount:{SUM(amount)}").where("receipt.remittanceid=:remittanceid AND fund.objid =:fundid AND NOT(reftype = 'CHECK') ", ppp ).val();
			if(!u.totalcr ) u.totalcr = 0;

			rfEm.find( [objid: it.objid ] ).update( u );
		}

		def t = rfEm.find( z ).select( "totalcash:{SUM(totalcash)},totalcheck:{SUM(totalcheck)},totalcr:{SUM(totalcr)},amount:{SUM(amount)}" ).first();
		remEm.find( [objid: m.objid]).update(t);
		//update total check and total 
		return m;
	}

	@ProxyMethod
	public void updateCash( def m ) {
		if(!m.objid) throw new Exception("objid is required");
		if(!m.cashbreakdown) throw new Exception("breakdown is required");
		if(!m.remittanceid ) throw new Exception("remittanceid is required");
		if(!m.totalcash ) throw new Exception("totalcash is required");

		def bd = m.cashbreakdown.findAll{ it.qty > 0 };
		rfEm.find( [objid: m.objid] ).update( [cashbreakdown: bd, totalcash: m.totalcash ] );

		def list = rfEm.select("cashbreakdown").find( [remittanceid: m.remittanceid ] ).list()*.cashbreakdown;
		bd = cashBreakdownSvc.summarize( list );

		def total = rfEm.find([ remittanceid: m.remittanceid ]).select('totalcash:{SUM(totalcash)}').val();
		remEm.find( [objid: m.remittanceid ] ).update( [cashbreakdown: bd, totalcash: total ] );
	}	

	@ProxyMethod
	public def submitForLiquidation( def o ) {
		//check total breakdown before submitting
		def z = rfEm.select("objid").find([ remittanceid: o.objid ]).where(" (amount - (totalcash+totalcheck+totalcr)) > 0 ").first();
		if ( z ) throw new Exception("Please ensure that all balances must be equal to 0. Please check there may be items that do not have a cash breakdown");

		def m = [ state: 'OPEN' ];	
		m.dtposted = dateSvc.getServerDate(); 

		if ( o.controlno.toString().toUpperCase().startsWith("REM")) {
			// do nothing, we will use the same transaction number 
		} else {
			def txncode = [ "REM", env.TXNCODE, env.ORGTXNCODE ].findAll{( it )}.join("-");
			m.controlno = controlSvc.formatTxnno([ txncode: txncode, txndate: m.dtposted, format: var.remittance_format, sequenceid_format: var.remittance_sequenceid_format ]); 

			rfEm.find([ remittanceid: o.objid ]).select('objid,fund.code').list().each{ 
				def txnno = m.controlno + (it.fund?.code ? ('-'+it.fund.code) : ""); 
				rfEm.find([ objid: it.objid ]).update([ controlno: txnno ]); 
			} 
		} 

		if ( o.collector?.signature ) m.collector = [signature: o.collector.signature]; 

		remEm.find([ objid: o.objid ]).update( m );
		o.putAll( m ); 
		return o;
	}

	@ProxyMethod
	public void acceptForLiquidation( param ) { 
		def m = [ state: 'POSTED']; 
		m.liquidatingofficer = [ objid: env.USERID, name: env.FULLNAME, title: env.JOBTITLE ]; 
		remEm.find([ objid: param.objid ]).update( m); 
	}

	@ProxyMethod 
	public void sendBack( param ) { 
		def info = remEm.find([ objid: param.objid ]).select('objid,state').first(); 
		if ( !info ) throw new Exception('Remittance record not found'); 

		if ( info.state.toString().toUpperCase() != 'OPEN' ) {
			throw new Exception('This action is only applicable for transaction with OPEN status'); 
		}

		def m = [ state: 'DRAFT' ]; 
		m.liquidatingofficer = [ objid: null, name: null, title: null ]; 
		remEm.find([ objid: param.objid ]).update( m ); 
	}

	@ProxyMethod 
	public def getReportData( params ) { 
		return params; 
	} 
}
