import com.rameses.annotations.*;
import com.rameses.util.*;
import java.rmi.server.*;

class RemittanceService  {


	@Env
	def env;

	@Service("DateService")
	def dateSvc;

	@Service("CashBreakdownSummaryService")
	def cashBreakdownSvc;

	@Service("SequenceService")
	def seqSvc;

	@DataContext("cashreceipt")
	def cashReceiptEm;

	@DataContext("remittance")
	def remEm;

	@DataContext("remittance_fund")
	def rfEm;

	@DataContext("cashreceiptpayment_noncash")
	def ncEm;

	@ProxyMethod
	public def create( def pp ) {
		def o = pp.items;

		def buff = new StringBuilder();
		o.findAll{ it.formtype == "serial" && ( it.qty != (it.toseries - it.fromseries + 1 ))  }.each {
			buff.append( it.formno + " " + it.stubno + " " + it.fromseries + " " + it.toseries );
		}
		def str = buff.toString();
		if(str ) throw new Exception("Mismatch qty with series. Please check the ff: \n" + str );

		def m = [:];
		m.controlno = 'TMP-REM-'+env.USERID;
		m.controldate = dateSvc.getBasicServerDate();
		m.dtposted = dateSvc.getServerDate();
		m.state = "DRAFT";
		m.totalcash = 0;
		m.totalcheck=0;
		m.totalcr = 0;
		m.cashbreakdown = [];
		m.collector = [objid:env.USERID, name: env.FULLNAME, title: env.JOBTITLE ]; 
		m.amount = 0;
		m = remEm.create( m );

		def scond = "collector.objid = :userid AND series BETWEEN :fromseries AND :toseries";
		o.each {
			//update also remittance_fund
			def p = [userid: env.USERID, fromseries: it.fromseries, toseries: it.toseries ];
			cashReceiptEm.find( [controlid: it.afcontrolid ] ).where(scond, p).update( [remittanceid: m.objid] );
		}

		def z = [remittanceid: m.objid]
		remEm.insertRemittanceAF( z );
		remEm.insertRemittanceFund( z );
		remEm.updateNonCashPayment( z );

		def clist = rfEm.find( z ).list();
		clist.each {
			def u = [:];
			u.amount = it.amount;
			u.totalcheck = ncEm.find( [remittancefundid: it.objid ]).select( "amount:{SUM(amount)}").where("reftype = 'CHECK' ").val();
			if(!u.totalcheck) u.totalcheck = 0;
			u.totalcr = ncEm.find( [remittancefundid: it.objid ]).select( "amount:{SUM(amount)}").where(" NOT( reftype = 'CHECK') ").val();
			if(!u.totalcr ) u.totalcr = 0;
			u.totalcash = u.amount - u.totalcheck - u.totalcr;
			rfEm.find( [objid: it.objid ] ).update( u );
		}

		def t = rfEm.find( z ).select( "totalcash:{SUM(totalcash)},totalcheck:{SUM(totalcheck)},totalcr:{SUM(totalcr)},amount:{SUM(amount)}" ).first();
		remEm.find( [objid: m.objid]).update(t);
		//update total check and total 
		return m;
	}

	@ProxyMethod
	public void updateRemittanceFundBreakdown( def m ) {
		if(!m.objid) throw new Exception("objid is required");
		if(!m.cashbreakdown) throw new Exception("breakdown is required");
		if(!m.remittanceid ) throw new Exception("remittanceid is required");

		def bd = m.cashbreakdown.findAll{ it.qty > 0 };
		rfEm.find( [objid: m.objid] ).update( [cashbreakdown: bd ] );

		def list = rfEm.select("cashbreakdown").find( [remittanceid: m.remittanceid ] ).list()*.cashbreakdown;
		bd = cashBreakdownSvc.summarize( list );

		remEm.find( [objid: m.remittanceid ] ).update( [cashbreakdown: bd ] );
	}	

	@ProxyMethod
	public def post( def o ) {
		//check total breakdown before submitting
		def z = remEm.find( [objid: o.objid ] ).select("totalcash,cashbreakdown").first();
		if( z.totalcash > 0 && !z.cashbreakdown )
			throw new Exception("Please ensure cash breakdown in each remittance fund is correct ");

		if( z.cashbreakdown ) {
			if( z.totalcash != z.cashbreakdown.sum{it.amount}  )
				throw new Exception("Cash breakdown does not match total cash");	
		}

		o.controlno = 'REM-'+env.USER;
		o.state = 'POSTED';
		remEm.find( [objid: o.objid ] ).update( o );

		//update also each remittance fund to fund
	}


}
