import com.rameses.annotations.*;

class AFTransactionInterceptor {

	@Service("SequenceService") 
	def seqSvc;

	@Service("DateService") 
	def dateSvc;

	@DataContext("af_control_detail")
	def afcd;

	@DataContext("af_control")
	def afc;

	@DataContext('aftransaction') 
	def aftrans;

	@Before(pattern="PersistenceService.create", eval="#{ args[0]._schemaname == 'aftransaction' }")
	public void beforeCreate(def evt) {
		def o = evt.args[0];
		o.controlno = "AFTXN" + seqSvc.getNextFormattedSeries("AFTXN");
		o.txndate = dateSvc.getServerDate();
		o.state = "DRAFT";
	}	

	@After(pattern="PersistenceService.create", eval="#{ args[0]._schemaname == 'aftransaction' }")
	public void afterCreate(def evt) {
		def o = evt.args[0];
		def m = [ objid: o.objid ]; 
		def txntype = o.txntype.toString().toUpperCase(); 

		o.items.each { 
			def afcparam = [ objid: it.objid ]; 
			afc.syncCurrentIndexNo( afcparam ); 

			m.controlid = it.objid; 
			if ( txntype == 'TRANSFER' ) {
				aftrans.postTransfer( m ); 
				afc.find([ afcparam ]).update([ owner: o.collector ]);

			} else if ( txntype == 'RETURN' ) {
				aftrans.postReturn( m ); 
				afc.find([ afcparam ]).update([ state:'OPEN', owner: [objid: null, name: null], assignee: [objid: null, name: null]]); 

			} else if ( txntype == 'CANCEL' ) { 
				aftrans.postCancel( m ); 
				afc.find([ afcparam ]).update([ state:'CANCELLED', owner: [objid: null, name: null], assignee: [objid: null, name: null]]); 

			} else if ( txntype == 'REVERT_CANCEL' ) { 
				def fo = afc.find([ afcparam ]).first(); 
				if ( fo?.state.toString().toUpperCase() != 'CANCELLED' ) 
					throw new Exception('Accountable Form must be in CANCELLED state');  

				def li = afcd.find([ controlid: it.objid ]).orderBy('indexno desc, refdate desc').first(); 
				if ( li?.txntype.toString().toUpperCase() !='CANCEL' ) 
					throw new Exception('The last AF transaction must be in CANCEL type');  

				li.objid = o.objid; 
				li.indexno += 1; 
				li.refid = o.objid;
				li.refno = o.controlno;
				li.refdate = o.dtfiled;
				li.txndate = o.txndate;
				li.txntype = txntype;
				li.reftype = 'aftransaction'; 
				li.remarks = 'REVERT CANCELLATION';
				if ( li.beginstartseries > 0 && li.beginendseries > 0 ) {
					li.qtybegin = (li.beginendseries-li.beginstartseries)+1; 

					li.endingstartseries = li.beginstartseries; 
					li.endingendseries = li.beginendseries; 
					li.qtyending = li.qtybegin;
				} 
				afcd.create( li ); 

				def upd = [ state:'OPEN', owner: [objid: null, name:null], assignee: [objid: null, name: null]]; 
				if ( li.issuedto?.objid ) { 
					upd.owner = li.issuedto; 
					upd.assignee = li.issuedto; 
					upd.state = 'ISSUED'; 
				}
				afc.find([ objid: it.objid ]).update( upd );

			} else if ( txntype == 'REVERT_SALE' ) { 
				def fo = afc.find([ afcparam ]).first(); 
				if ( fo?.state.toString().toUpperCase() != 'ISSUED' ) 
					throw new Exception('Accountable Form must be in ISSUED state');  

				def li = afcd.find([ controlid: it.objid ]).orderBy('indexno desc, refdate desc').first(); 
				if ( li?.txntype.toString().toUpperCase() !='SALE' ) 
					throw new Exception('The last AF transaction must be in SALE type');  

				li.objid = o.objid; 
				li.indexno += 1; 
				li.refid = o.objid;
				li.refno = o.controlno;
				li.refdate = o.dtfiled;
				li.txndate = o.txndate;
				li.txntype = txntype;
				li.reftype = 'aftransaction'; 
				li.remarks = 'REVERT SALE';
				afcd.create( li ); 

				def upd = [ state:'OPEN', owner: [objid: null, name:null], assignee: [objid: null, name: null]]; 
				afc.find([ objid: it.objid ]).update( upd ); 

			} else {
				throw new Exception(''+ txntype +' invalid transaction type used'); 
			}

			afc.syncCurrentIndexNo( afcparam ); 
		} 
	}	

	@After(pattern="PersistenceService.read", eval="#{ args[0]._schemaname == 'aftransaction' }")
	public void afterOpen(def evt) {
		def o = evt.result;
	}	


}
