import com.rameses.annotations.*;
import com.rameses.common.*;
import com.rameses.util.*;

class CloudNotificationService
{   
    @ActiveDB(value='cloud_notification', em='notification')
    def em;

    @Service('DateService')
    def dateSvc;

    @Env
    def env;

    @ProxyMethod 
    public def addMessage( msg ) { 
        if (!msg) throw new Exception('Please provide parameters'); 
        if (!msg.objid) msg.objid = 'MSG'+new java.rmi.server.UID(); 
        if (!msg.senderid) msg.senderid = env.USERID; 
        if (!msg.sender) msg.sender = (env.FULLNAME? env.FULLNAME: env.NAME); 
        if (!msg.channelgroup) msg.channelgroup = msg.channel; 
        if (!msg.messagetype) msg.messagetype = 'notification'; 
        if (!msg.attachmentcount) msg.attachmentcount = 0;

        def userObj = (msg.data? msg.data: [:]); 
        if (userObj instanceof AsyncRequest) { 
            if (!msg.message) msg.message = 'New Async Request';         
            if (!msg.messagetype) msg.messagetype = 'async_request'; 
            if (!msg.filetype) msg.filetype = 'async_request'; 
            if (!msg.groupid) msg.groupid = 'async_request'; 
        } 

        def rundate = dateSvc.serverDate;
        msg.dtfiled = rundate.toString(); 
        msg.data = new Base64Cipher().encode(userObj); 
        em.create( msg ); 
        msg.data = userObj; 

        def pendingdata = [
            objid:      msg.objid,
            dtfiled:    msg.dtfiled, 
            dtexpiry:   dateSvc.add(rundate, '5m'), 
            dtretry:    msg.dtfiled,
            type:       'HEADER' 
        ]; 
        em.create( pendingdata, 'pending' ); 

        msg.traceid = 'RCVMSG' + new java.rmi.server.UID(); 
        msg.tracetime = msg.dtfiled; 
        em.create( msg, 'received' ); 
        return msg; 
    } 

    @ProxyMethod 
    public void removeMessage( params ) { 
        def data = em.read( params ); 
        if (!data) return; 

        em.removeFailed( [refid: data.objid] ); 
        em.removePending( data ); 
        em.removeDelivered( data ); 
        em.removeReceived( data ); 
        em.delete( data ); 
    } 


    @ProxyMethod 
    public def addAttachment( data ) { 
        if (!data) throw new Exception('Please provide parameters'); 

        def header = em.read([objid: data.parentid]); 
        if (!header) throw new Exception("'"+data.parentid+"' header record not found"); 
        if (!data.objid) data.objid = 'ATTC'+new java.rmi.server.UID(); 

        def rundate = dateSvc.serverDate;
        data.dtfiled = rundate.toString(); 
        em.create( data, 'attachment' ); 

        def pendingdata = [
            objid:      data.objid,
            dtfiled:    data.dtfiled, 
            dtexpiry:   dateSvc.add(rundate, '5m'), 
            dtretry:    data.dtfiled,
            type:       'ATTACHMENT' 
        ]; 
        em.create( pendingdata, 'pending' ); 
        return data;  
    } 

    @ProxyMethod 
    public void removeAttachment( params ) { 
        def data = em.read( params, 'attachment' ); 
        if (!data) return; 

        em.removeFailed( [refid: data.objid] ); 
        em.removePending( data );         
        em.delete( data, 'attachment' ); 
    }  

    @ProxyMethod 
    public def getAttachments( params ) {
        return em.getAttachments( params ); 
    }

    @ProxyMethod 
    public def getList( params ) {
        return em.getList( params ); 
    } 

    @Async 
    @ProxyMethod
    public void markAsFailed( params ) {
        em.removePending( [objid: params.objid] );   

        def data = [
            objid:          'FMSG'+new java.rmi.server.UID(), 
            dtfiled:        dateSvc.serverDate, 
            refid:          params.objid, 
            reftype:        params.type, 
            errormessage:   params.errormessage 
        ];
        em.create( data, 'failed' ); 
    } 

    @ProxyMethod 
    public void rescheduleFailedMessage( params ) {
        if ( !params.objid ) throw new Exception('objid parameter is required');

        rescheduleFailedMessages([ objid: params.objid ]); 
    } 

    @ProxyMethod 
    public void rescheduleFailedMessages( params ) {
        if ( !params.items ) throw new Exception('items parameter is required');

        params.items.each { o-> 
            def data = em.findFailedMessage( o ); 
            if ( !data ) return; 

            def rundate = dateSvc.serverDate; 
            def pendingdata = [
                objid:      data.objid,
                dtfiled:    rundate, 
                dtexpiry:   dateSvc.add(rundate, '5m'), 
                dtretry:    rundate,
                type:       'HEADER' 
            ]; 
            em.create( pendingdata, 'pending' ); 
            em.removeFailed([ refid: data.objid ]); 
        }        
    } 



    @Service(value='CloudNotificationService', connection='cloud_notification')
    def remote;

    /*
        this is intended for remote proxying to cloud notifcation 
    */
    @ProxyMethod
    public def markAsDelivered( params ) { 
        return remote.markAsDelivered( params ); 
    }     
} 
