
import com.rameses.annotations.*;
import com.rameses.common.*;
import com.rameses.util.*;
import com.rameses.osiris3.core.AppContext;
import com.rameses.osiris3.core.OsirisServer;
import com.rameses.osiris3.script.*;
import com.rameses.osiris3.xconnection.XConnection;
import java.rmi.server.UID;
import java.io.PrintWriter;
import java.io.StringWriter;

class AsyncNotificationNotifyTask 
{	
    @ActiveDB(value='async_notification', em='notification')
    def em;

    @Service('AsyncNotificationService') 
    def asyncNotificationSvc; 

	@Service('AsyncRequestExecutor')
	def asyncReqExecutor;    

	@Service('DateService')
	def dateSvc;    

	//@Schedule(interval=2)
	public void fetchPendingData( task ) {
		def rundate = dateSvc.serverDate;
		if (!task.properties.loaded) { 
			//server has just started, remove all processes 
			println 'removing previous async notification processes...'			
			em.removeProcessBefore([dtfiled: rundate]); 
			task.properties.loaded = true; 

		} else {
			def list = em.getProcessList([ _start:0, _limit:5 ]); 
			if ( !list ) { 	
				em.moveToProcessing([ rundate: rundate ]); 
				return; 
			} 

			while (!list.isEmpty()) { 
				def data = list.remove(0); 
				data.rundate = rundate; 
				try { 
					publishMessage( data ); 
				} catch(Throwable t) { 
					println '[AsyncNotificationNotifyTask] failed to process pending message caused by ' + t.class.name + ': ' + t.message; 
				} 
			} 
		}
	} 

	public void publishMessage( params ) { 
		def msgObj = em.read( params ); 
		if ( msgObj ) {
			asyncReqExecutor.process( msgObj );  
		} else { 
			asyncNotificationSvc.removeEntity( msgObj ); 
		} 
	} 
} 
