
import com.rameses.annotations.*;
import com.rameses.common.*;
import com.rameses.util.*;
import com.rameses.osiris3.core.AppContext;
import com.rameses.osiris3.core.OsirisServer;
import com.rameses.osiris3.script.*;
import com.rameses.osiris3.xconnection.XConnection;
import java.rmi.server.UID;
import java.io.PrintWriter;
import java.io.StringWriter;

class AsyncNotificationNotifyTask 
{	
    @ActiveDB(value='async_notification', em='notification')
    def em;

    @Service('AsyncNotificationService') 
    def service; 

	@Service('DateService')
	def dateSvc;    

	@Service 
	def self; 

	@Env 
	def sysEnv; 

	@Schedule(interval=2)
	public void fetchPendingData( task ) {
		def rundate = dateSvc.serverDate;
		if (!task.properties.loaded) { 
			//server has just started, remove all processes 
			println 'removing previous async notification processes...'			
			em.removeProcessBefore([dtfiled: rundate]); 
			task.properties.loaded = true; 

		} else {
			def list = em.getPendingList([_start:0, _limit:20, _pagingKeys:'p.objid']); 
			while (!list.isEmpty()) {
				def data = list.remove(0); 
				data.rundate = rundate; 
				processPendingData( data ); 
			}
		}
	} 

	private void processPendingData( data ) {
		try { 
			def rundate = data.rundate; 
			if (data.dtretry && data.dtretry.before(rundate)) { 
				def procdata = [objid:data.objid, dtfiled:rundate];
				em.create( procdata, 'processing' ); 
				self.publishMessage( data ); 
			} else { 
				//rerun on next schedule 
			} 
		} catch(Throwable t) { 
			println '[AsyncNotificationNotifyTask] failed to process pending message caused by ' + t.class.name + ': ' + t.message; 
		} 
	} 

	@Context 
	def currentContext;

	@Async
	@ProxyMethod(local=true) 
	public void publishMessage( params ) { 
		try { 
			def msgObj = em.read([objid: params.objid]); 
			if (!msgObj) return; 

			def asyncReq = new Base64Cipher().decode(msgObj.data); 
			if (!asyncReq.contextName) asyncReq.contextName='default'; 

			def envmap = (sysEnv? sysEnv: [:]);
			envmap.REQUESTER = (asyncReq.env? asyncReq.env: [:]); 
			envmap.ASYNC = [ID:asyncReq.id, CONNECTION:asyncReq.connection]; 

			def xconn = currentContext.getResource( XConnection.class, asyncReq.contextName+'_proxy' ); 
			def proxy = xconn.create( asyncReq.serviceName, envmap ); 
			def result = proxy.invokeMethod( asyncReq.methodName, asyncReq.args ); 
			if (result instanceof AsyncToken) { 
				service.markAsDelivered([ objid:params.objid ]); 
			} else { 
				processResult(asyncReq, params.objid, result); 
			} 
		} catch(e) { 
			e.printStackTrace();
			processError(e, params.objid); 
 		}
	} 

	private void processResult(asyncReq, msgid, result) { 
		def connName = asyncReq.connection; 
		if (connName) {
			def xconn = currentContext.getResource( XConnection.class, connName ); 
			if (xconn) { 
				def queue = xconn.register( asyncReq.id ); 
				queue.push( result ); 
				queue.push( new AsyncToken(closed:true) ); 
			} else {
				println "[AsyncNotificationNotifyTask] '"+ connName + "' connection not found"; 
			} 
		} 
		//update the message status
		service.markAsDelivered([objid: msgid]); 
	} 

	private void processError(exception, msgid) {
		try {
			service.reschedulePending([objid: msgid]); 
			def info = service.findPending([objid: msgid]); 
			if (info?.retrycount > 3) {
				if (!exception) exception=new Exception('Message already expired');

				def buffer = new StringWriter();
				exception.printStackTrace(new PrintWriter(buffer)); 
				service.markAsFailed([ 
					objid 		 : msgid, 
					errormessage : buffer.toString()  
				]); 
			}
		} catch(e) { 
			e.printStackTrace(); 
		} 
	} 
} 
