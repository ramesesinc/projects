import com.rameses.annotations.*;
import java.text.*;
import com.rameses.functions.*;
import com.rameses.util.*;
import market.facts.*;
import com.rameses.rules.common.*;

import treasury.utils.*;
import treasury.facts.*;

class MarketBillingService {
	
	@Service("AssessmentRuleService")
	def assmtSvc;

	@DataContext("market_account")
	def acctEm;

	@Service("DateService")
	def dateSvc;

	def monthNames = ['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC'];

	/***************************************************************************************************
	* STEPS: 
	*     1. Determine where date to start. Startdate or last date paid (last date covered). Add 1 day.
	*     2. If there is partial balance, do not move the date. to the next date from last payment date. 
	*     3. This returns the bill items in its raw form i.e. not summaried to period
	****************************************************************************************************/
	@ProxyMethod
	public def process( def o, def resultHandler ) {
		if(!o.fromdate) throw new Exception("fromdate is required in MarketBillingService");
		if(!o.marketunit) throw new Exception("marketunit is required in MarketBillingService");

		def svrDate = dateSvc.getBasicServerDate();
		def todate = svrDate;
		if( o.payoption?.todate ) {
			todate = dateSvc.parseDate( o.payoption.todate, null ).date;
		}
		def amtPaid = 0.0;
		if( o.payoption?.amount ) {
			amtPaid = o.payoption.amount;
		}

		def fb = new FactBuilder();
		fb.facts << new MarketRentalUnit( o.marketunit );
		fb.facts << new MarketBillingPeriod( [fromdate: o.fromdate, todate: todate ] ) ;
		fb.facts << new treasury.facts.SystemDate(svrDate);
		fb.facts << new treasury.facts.BillDate( (o.billdate) ?o.billdate: svrDate );
		fb.facts << new treasury.facts.Payment( amount: amtPaid );
		return assmtSvc.execute( "marketbilling", [:], fb, resultHandler );
	}


	@ProxyMethod
	public def getBilling( def o, def resultHandler ) {
		if( !o.acctid ) throw new Exception("acctid is required in MarketBillingService.getBilling");
		def str = "todate,startdate,rate,extrate,payfrequency,partialbalance,partialextbalance,unittype:{unit.unittype}";
		def acct = acctEm.select(str).find([objid:o.acctid]).first();
		if(!acct) throw new Exception("Account not found");

		def svrDate = dateSvc.getBasicServerDate();
		def req = [:];
		req.marketunit = [
			unittype:acct.unittype, 
			payfrequency:acct.payfrequency,
			rate:acct.rate, extrate:acct.extrate,
			partialbalance:(acct.partialbalance==null)?0:acct.partialbalance, 
			partialextbalance:(acct.partialextbalance==null)?0:acct.partialextbalance
		];	
		req.fromdate = (acct.todate!=null)?acct.todate : acct.startdate; 
		req.payoption = o.payoption;
		req.billdate = (o.billdate!=null)? dateSvc.parseDate(o.billdate,null).date: svrDate;

		return process( req, resultHandler);
	}

}