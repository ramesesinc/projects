import com.rameses.annotations.*;
import java.text.*;
import com.rameses.functions.*;
import com.rameses.util.*;
import market.facts.*;
import com.rameses.rules.common.*;

import treasury.utils.*;
import treasury.facts.*;

class MarketBillingService {
	
	@Service("AssessmentRuleService")
	def assmtSvc;

	@DataContext("market_account")
	def acctEm;

	@Service("DateService")
	def dateSvc;

	@DataContext("market_account_recurringfee")
	def recurFeeEm;

	@DataContext("market_otherfee")
	def otherFeeEm;


	/***************************************************************************************************
	* STEPS: 
	*     1. Determine where date to start. Startdate or last date paid (last date covered). Add 1 day.
	*     2. If there is partial balance, do not move the date. to the next date from last payment date. 
	*     3. This returns the bill items in its raw form i.e. not summaried to period
	****************************************************************************************************/
	@ProxyMethod
	public def process( def o, def resultHandler ) {
		if(!o.fromdate) throw new Exception("fromdate is required in MarketBillingService");
		if(!o.marketunit) throw new Exception("marketunit is required in MarketBillingService");

		def amtPaid = 0.0;
		def svrDate = dateSvc.getBasicServerDate();
		def todate = svrDate;
		
		if(o.payoption) {
			if( o.payoption.todate ) {
				todate = dateSvc.parseDate( o.payoption.todate, null ).date;
			}
			else if( o.payoption.numdays ) {
				todate = DateUtil.add( o.fromdate, (o.payoption.numdays-1) + "d" );
			}
			else if( o.payoption.nummonths ) {
				todate = DateUtil.add( o.fromdate, o.payoption.nummonths + "M" );
				todate = DateUtil.add( todate, "-1d");
			}
			else if( o.payoption?.amount ) {
				amtPaid = o.payoption.amount;
			}
		}

		def fb = new FactBuilder();
		fb.facts << new MarketRentalUnit( o.marketunit );
		fb.facts << new MarketBillingPeriod( [fromdate: o.fromdate, todate: todate ] ) ;
		fb.facts << new treasury.facts.SystemDate(svrDate);
		fb.facts << new treasury.facts.BillDate( (o.billdate) ?o.billdate: svrDate );
		fb.facts << new treasury.facts.Payment( amount: amtPaid );

		MonthEntryBuilder.buildMonthEntries( o.fromdate, todate ).each {
			fb.facts << it;
		};

		//add the recurring and other fees
		recurFeeEm.find( [acctid: o.acctid ]).list().each {
			fb.facts << new RecurringFee( txntype: it.txntype.objid, amount: it.amount )
		};
		
		//println "Other Fees*****************************"
		otherFeeEm.find( [acctid: o.acctid ]).list().each {
			def mf = new MonthBillItem( refid:it.objid, year: it.year, month: it.month, txntype: it.txntype?.objid, amount:it.balance, remarks: it.remarks );
			fb.facts << mf;
		};
		return assmtSvc.execute( "marketbilling", [:], fb, resultHandler );
	}


	@ProxyMethod
	public def getBilling( def o ) {
		if( !o.acctid ) throw new Exception("acctid is required in MarketBillingService.getBilling");
		def str = "startdate,unittype:{unit.unittype},payfrequency,ratetype:{unit.ratetype},rate,clusterid:{unit.cluster.objid},sectionid:{unit.section.objid},unitid:{unit.objid},partialbalance";
		def acct = acctEm.select(str).find([objid:o.acctid]).first();
		if(!acct) throw new Exception("Account not found");

		def svrDate = dateSvc.getBasicServerDate();
		def req = [:];
		req.acctid = o.acctid;
		req.marketunit = [
			unittype:acct.unittype, 
			payfrequency:acct.payfrequency,
			ratetype: acct.ratetype,
			rate:acct.rate, 
			clusterid:acct.clusterid,
			sectionid:acct.sectionid,
			unitid: acct.unitid,
			partialbalance:(acct.partialbalance==null)?0:acct.partialbalance
		];	
		req.fromdate = acct.startdate; 
		//req.payoption = o.payoption;

		//test
		req.payoption = [amount:3500.00];

		req.billdate = (o.billdate!=null)? dateSvc.parseDate(o.billdate,null).date: svrDate;

		def m = [items:[]];
		def resultHandler = [
			getFactKeyValue : { v->
				if( v instanceof MarketLedgerStatus ) {
					m.ledgerstatus = [
						startdate: v.startdate, 
						partialbalance: v.partialbalance
					];
				}
				else if( v instanceof MarketBillingPeriod ) {
					m.fromdate = v.fromdate;
					m.todate = v.todate;
				}
				else if(v instanceof DueDate ) {
					m.duedate = v.date;
				}
				else if(v instanceof BillItem) {
					def itm = v.toMap();
					m.items << itm;
				}	
				else if( v instanceof SummaryBillItem ) {
					def itm = v.toMap();
					m.items << itm;									
				}
				else if( v instanceof BillSubItem ) {
					def itm = v.toMap();
					itm.year = v.parent.year;
					itm.month = v.parent.month;
					m.items << itm;
				}
				return null;
			}
		] as ResultHandler;

		process( req, resultHandler);
		if(!m.items) 
			throw new Exception("No billitems found");

		m.items = m.items.sort{  ((it.year*12)+it.month) };
		
		return m;
	}

}