import com.rameses.annotations.*;
import com.rameses.util.*;
import java.rmi.server.*;
import com.rameses.services.extended.*;
import market.facts.*;
import java.text.*;
import treasury.utils.*;
import treasury.facts.*;


public class MarketCashReceiptService  {

	@DataContext("market_account")
	def acctEm;

	@Service("MarketBillingService")
	def billingSvc;

	@Service("DateService")
	def dateSvc;

	def df = new java.text.SimpleDateFormat("yyyy-MM-dd");
	
	@ProxyMethod
	public def getBillItem( def o ) {
		if(!o.fromdate)
			throw new Exception("from date is required");
		def r = [acctid: o.objid];
		def a = acctEm.find([objid: o.objid] ).first();

		if( o.filters ) r.filters = o.filters;
		if( o.todate ) {
			r.billdate = o.todate;
			r.todate = o.todate;
		}	

		if( o.partial ) r.partial = o.partial;

		
		def m = billingSvc.getBilling( r );

		//build the receipt items:
		def items = [];
		def itemGrp = m.items.groupBy{ it.item };
		itemGrp.each { k,v->
			def minItem = v.min{ (it.year * 12)+it.month };
			def maxItem = v.max{ (it.year * 12)+it.month };
			
			def remarks = "Unit " + a.unitno + " ";
			if(minItem.year == maxItem.year) {
				if( minItem.month == maxItem.month) {
					remarks += maxItem.monthname + " " + maxItem.year;
				}
				else {
					remarks += minItem.monthname + " to " + maxItem.monthname + " " + maxItem.year;
				}
			}
			else {
				remarks += minItem.monthname + " " + minItem.year + " to " + maxItem.monthname + " " + maxItem.year;
			};
			items << [item: k, 
				amount: v.sum{it.amount}, 
				remarks:  remarks
			];
		}

		def result = [:];
		result.acctno = a.acctno;
		result.acctid = a.objid;
		result.unitno = a.unitno;
		result.billitems = m.billitems;
		result.items = items;
		result.amount = m.amount;
		result.fromdate = m.fromdate;
		result.todate = m.todate;
		return result;
	}

}