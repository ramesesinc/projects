import com.rameses.annotations.*;
import java.text.*;
import com.rameses.functions.*;
import com.rameses.util.*;
import com.rameses.rules.common.*;

class MarketPaymentService {
	
	@DataContext("market_payment")
	def pmtEm;

	@DataContext("market_payment_item")
	def pmtiEm;

	@DataContext("market_account")
	def acctEm;

	@Service("DateService")
	def dateSvc;

	def dformat = new SimpleDateFormat("yyyy-MM-dd");

	/*********************************************************************
	* Adjust todate. If there is partial balance, deduct one day.
	*********************************************************************/
	@ProxyMethod
	public def postCreate( def r ) {
		def m = [:];
		m.objid = r.objid;
		m.txnno = r.receiptno;
		m.txndate = r.txndate;
		m.acctid = r.acctid;
		m.fromdate = r.fromdate;
		m.todate = r.todate;
		m.reftype = "cashreceipt";
		m.refid = r.objid;					//the cash receipt objid
		m.refno = r.receiptno;		
		m.refdate = r.receiptdate;
		m.amount = r.amount;
		m.txnmode = 'ONLINE';
		m.voided = 0;

		//use the billitems as the details for payment.
		r.billitems.each {
			it.parent = m;
		}
		//find the items that is not surcharge or interest.
		m.items = r.billitems;

		//find the last payment id so we can store it in the payment.
		def prev = acctEm.find( [objid: m.acctid] ).select( "lastpaymentid,partialbalance,partialextbalance,lastdatepaid").first();
		m.prevlastdatepaid = prev.lastdatepaid;
		m.prevpartialbalance = prev.partialbalance;
		m.prevpartialextbalance = prev.partialextbalance;
		m.prevpaymentid = prev.lastpaymentid;

		//create the payment.
		pmtEm.create( m );

		//calculate the last datepaid. It must be m.todate because it is already converted to date.
		def lastdatepaid = m.todate;
		if( r.partialbalance && r.partialbalance >0 ) {
			lastdatepaid = DateUtil.add( m.todate, "-1d" );
		};

		//update the ledger
		acctEm.find( [objid: m.acctid] ).update( [
			lastdatepaid: lastdatepaid, 
			partialbalance: r.partialbalance, 
			partialextbalance: r.partialextbalance,
			lastpaymentid: m.objid 
		]);

	}


	/********************************************************************
	* steps to void: 
	* 1. retrieve total rate and extension rate issued in receipt
	* 2. retrieve account last date paid and partial unpaid balances
	* 3. get number of days to reverse based on rate paid over daily rate
	* 4. get if there is remainder paid, add to partialbalance. If this amount
			is less than  
	*********************************************************************/
	@ProxyMethod
	public def postVoid( def o ) {
		def pmt = pmtEm.read( [objid: o.refid] );

		def acct = acctEm.find( [objid: pmt.acctid] ).select("lastpaymentid").first(); 
		if(acct.lastpaymentid!=null && acct.lastpaymentid != pmt.objid ) 
			throw new Exception("Invalid last payment. Only the latest payment made can be voided. Please check the ledger");

		def z = [:];
		z.partialbalance = pmt.prevpartialbalance;	
		z.partialextbalance = pmt.prevpartialextbalance;
		z.lastdatepaid = pmt.prevlastdatepaid;
		z.lastpaymentid = pmt.prevpaymentid;

		acctEm.find( [objid: pmt.acctid] ).update(z);

		//void this payment	
		pmtEm.find( [refid: pmt.objid] ).update( [voided: 1] );
	}


}