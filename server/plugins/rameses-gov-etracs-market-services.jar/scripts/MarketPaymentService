import com.rameses.annotations.*;
import java.text.*;
import com.rameses.functions.*;
import com.rameses.util.*;
import com.rameses.rules.common.*;

class MarketPaymentService {
	
	@DataContext("market_payment")
	def pmtEm;

	@DataContext("market_payment_item")
	def pmtiEm;

	@DataContext("market_account")
	def acctEm;

	@Service("DateService")
	def dateSvc;

	def dformat = new SimpleDateFormat("yyyy-MM-dd");

	/*********************************************************************
	* Adjust todate. If there is partial balance, deduct one day.
	*********************************************************************/
	@ProxyMethod
	public def postCreate( def r ) {
		def m = [:];
		m.objid = r.objid;
		m.txnno = r.receiptno;
		m.txndate = r.txndate;
		m.acctid = r.acctid;
		
		m.reftype = "cashreceipt";
		m.refid = r.objid;					//the cash receipt objid
		m.refno = r.receiptno;		
		m.refdate = r.receiptdate;
		m.amount = r.amount;
		m.txnmode = 'ONLINE';
		m.voided = 0;

		m.items = r.items.findAll{ it.dynamic != true };
		m.items.each {
			it.parent = m;
			it.rate = r.unit.rate;
			if(it.extrate==null) it.extrate = 0;
		}
		
		//find the last payment id so we can store it in the payment.
		def prev = acctEm.find( [objid: m.acctid] ).select( "rate,extrate,lastpaymentid,partialbalance,partialextbalance,lastdatepaid").first();
		m.prevlastdatepaid = prev.lastdatepaid;
		m.prevpartialbalance = prev.partialbalance;
		m.prevpartialextbalance = prev.partialextbalance;
		m.prevpaymentid = prev.lastpaymentid;

		def firstItem = m.items.first();
		m.fromdate = firstItem.fromdate;
		def lastItem = m.items.last();
		m.todate =  lastItem.todate;

		//create the payment.
		pmtEm.create( m );


		//calculate the last datepaid. It must be m.todate because it is already converted to date.
		//calculate if there are kida in next balance;
		def partialbalance =  NumberUtil.round( lastItem.amount.doubleValue() % prev.rate.doubleValue() );
		def partialextbalance =  NumberUtil.round( lastItem.extrate.doubleValue()  % prev.extrate.doubleValue() );

		def u = [:];
		u.partialbalance = (partialbalance>0)? prev.rate - partialbalance : 0;
		u.partialextbalance = (partialextbalance>0)? prev.extrate - partialextbalance: 0;
		u.lastdatepaid = m.todate; 
		u.lastpaymentid = m.objid;

		//update the ledger
		acctEm.find( [objid: m.acctid] ).update( u );
	}


	/********************************************************************
	* steps to void: 
	* 1. retrieve total rate and extension rate issued in receipt
	* 2. retrieve account last date paid and partial unpaid balances
	* 3. get number of days to reverse based on rate paid over daily rate
	* 4. get if there is remainder paid, add to partialbalance. If this amount
			is less than  
	*********************************************************************/
	@ProxyMethod
	public def postVoid( def o ) {
		def pmt = pmtEm.read( [objid: o.refid] );

		def acct = acctEm.find( [objid: pmt.acctid] ).select("lastpaymentid").first(); 
		if(acct.lastpaymentid!=null && acct.lastpaymentid != pmt.objid ) 
			throw new Exception("Invalid last payment. Only the latest payment made can be voided. Please check the ledger");

		def z = [:];
		z.partialbalance = pmt.prevpartialbalance;	
		z.partialextbalance = pmt.prevpartialextbalance;
		z.lastdatepaid = pmt.prevlastdatepaid;
		z.lastpaymentid = pmt.prevpaymentid;

		acctEm.find( [objid: pmt.acctid] ).update(z);

		//void this payment	
		pmtEm.find( [refid: pmt.objid] ).update( [voided: 1] );
	}


}