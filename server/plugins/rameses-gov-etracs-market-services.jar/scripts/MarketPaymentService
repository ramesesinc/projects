import com.rameses.annotations.*;
import java.text.*;
import com.rameses.functions.*;
import com.rameses.util.*;
import com.rameses.rules.common.*;

class MarketPaymentService {
	
	@DataContext("market_payment")
	def pmtEm;

	@DataContext("market_payment_item")
	def pmtiEm;

	@DataContext("market_account")
	def acctEm;

	@Service("DateService")
	def dateSvc;

	def dformat = new SimpleDateFormat("yyyy-MM-dd");

	/*********************************************************************
	* Adjust todate. If there is partial balance, deduct one day.
	*********************************************************************/
	@ProxyMethod
	public def postCreate( def r ) {
		//create the payment.
		pmtEm.create( r );

		r.ledgerstatus.each { k,v->
			println k+"="+v;
		}
		//update the ledger
		acctEm.find( [objid: r.acctid] ).update( r.ledgerstatus );
	}


	/********************************************************************
	* steps to void: 
	* 1. retrieve total rate and extension rate issued in receipt
	* 2. retrieve account last date paid and partial unpaid balances
	* 3. get number of days to reverse based on rate paid over daily rate
	* 4. get if there is remainder paid, add to partialbalance. If this amount
			is less than  
	*********************************************************************/
	@ProxyMethod
	public def postVoid( def o ) {
		def pmt = pmtEm.read( [objid: o.refid] );

		def acct = acctEm.find( [objid: pmt.acctid] ).select("lastpaymentid").first(); 
		if(acct.lastpaymentid!=null && acct.lastpaymentid != pmt.objid ) 
			throw new Exception("Invalid last payment. Only the latest payment made can be voided. Please check the ledger");

		def z = [:];
		z.partialbalance = pmt.prevpartialbalance;	
		z.partialextbalance = pmt.prevpartialextbalance;
		z.todate = pmt.prevtodate;
		z.lastpaymentid = pmt.prevpaymentid;

		acctEm.find( [objid: pmt.acctid] ).update(z);

		//void this payment	
		pmtEm.find( [refid: pmt.objid] ).update( [voided: 1] );
	}


}