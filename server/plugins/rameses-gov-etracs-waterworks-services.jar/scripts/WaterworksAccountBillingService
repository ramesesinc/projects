import com.rameses.annotations.*;

import com.rameses.rules.common.*;
import waterworks.facts.*;
import treasury.facts.*;
import com.rameses.functions.*;

class WaterworksAccountBillingService  {
	
	@Service("RuleExecutorService")
	def ruleSvc;

	@Service("WaterworksBillingCycleService")
	def billingCycleSvc;

	@Service("DateService")
	def dateSvc;

	@DataContext("waterworks_account")
	def acct;

	@DataContext("waterworks_consumption")
	def consumption;

	@DataContext("waterworks_installment")
	def installment;

	void buildConsumptionFacts( def o, def facts ) {
		//account based on consmption
		def billCycle = facts.find{ it instanceof CurrentBillingCycle } 

		//consumption.debug = true; 
		def list = consumption.find([ acctid: o.objid ])
			.select("year:{billingcycle.year},month:{billingcycle.month},volume,amount,amtdue:{amount-amtpaid},duedate:{billingcycle.duedate},disconnectiondate:{billingcycle.disconnectiondate},refid:{objid}")
			.where(" (amount - amtpaid) > 0 ").list();

		//account based on installment	
		for ( d in list) { 
			facts << new WaterConsumption( d ); 
		} 
	} 

	void buildInstallmentFacts( def o, def facts ) {
		//find the last bill date. add installment from lastdatepaid until billdate
		def billCycle = facts.find{ it instanceof CurrentBillingCycle } 
		int yearMonth = (billCycle.year*12)+billCycle.month;

		def list2 = installment.find([acctid: o.objid]).where("amount - amtpaid > 0").list();
		for(x in list2) {
			def balance = (x.amount - x.downpayment) - x.amtpaid;
			def partialPaid = ( x.amtpaid.doubleValue() %  x.installmentamount.doubleValue() );
			int monthsPaid = (int)(x.amtpaid / x.installmentamount);

			int xYear = x.startyear;
			int xMonth = x.startmonth;
			int xYearMonth = (xYear*12)+xMonth;

			int paidCounter = 0;
			//loop for each month until it reaches the current billCycle
			while( xYearMonth <= yearMonth ) { 
				if ( paidCounter++ >= monthsPaid ) {  
					def amt = x.installmentamount;
					if( partialPaid > 0 ) {
						amt = partialPaid;
						partialPaid = 0;		
					};
					if( balance < amt ) amt = balance;
					facts << new WaterInstallment( year:xYear, month:xMonth, amount: amt, refid: x.objid, txntype: x.txntypeid );

					balance = balance - amt;
					if(balance == 0 ) break; 
				} 

				if( xMonth == 12 ) {
					xMonth = 1;
					xYear = xYear + 1;
				} else {
					xMonth = xMonth + 1;
				} 

				xYearMonth = (xYear*12)+xMonth;
			}
		}
	}

	def monthNames = ['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC'];

	private def toDate( Object value ) {
		if ( value == null ) return null; 
		else if ( value instanceof java.util.Date ) return value; 

		try {
			def formatter = new java.text.SimpleDateFormat('yyyy-MM-dd HH:mm:ss');
			return formatter.parse( value.toString() ); 
		} catch(Throwable t) {;}

		try {
			def formatter = new java.text.SimpleDateFormat('yyyy-MM-dd');
			return formatter.parse( value.toString() ); 
		} catch(Throwable t) {
			return null; 
		}
	}

	@ProxyMethod
	public def getBilling( def o ) {
		if(!o.acctid ) throw new Exception("acctid is required");
		def a = acct.find([objid:o.acctid]).first();
		if(!a) throw new Exception("Waterworks Account not found");

		def bc = billingCycleSvc.findCurrentCycle([sectorid:a.sector.objid, billdate: o.billdate]);

		def currDate = dateSvc.getBasicServerDate();
		def billDate = toDate( o.billdate !=null ? o.billdate : currDate);
		if ( billDate == null ) billDate = currDate;  

		def facts = [];
		facts << new CurrentDate( currDate );
		facts << new CurrentBillingCycle( bc );
		facts << new BillDate( billDate );
		facts << new WaterBillDate( bc );
		facts << new WaterAccount(a);

		buildConsumptionFacts( a, facts );
		buildInstallmentFacts( a, facts );

		def res = ruleSvc.execute( "waterworksbilling", facts, null, null );
		def feeList = [];
		facts.findAll{ it instanceof WaterBillItem }.each {
			def item = it.toItem();
			item.monthname = monthNames[item.month-1];
			item.particulars = (item.item.code? "("+item.item.code+") ":"") + item.item.title;
			feeList << item;
		};
		if (!feeList) return null; 

		a.items = feeList.findAll{ it.amount!=0 }.sort{ it.sortorder } 
		def grandtotal = a.items.sum{( it.amount? it.amount : 0.0 )} 
		if ( grandtotal==null ) grandtotal=0.0; 

		a.grandtotal = new BigDecimal( grandtotal );
		a.billdate = billDate;
		a.duedate = bc.duedate;
		a.currdate = currDate;
		return a;
	}	

	@ProxyMethod
	public def getItemizedBilling( o ) {
		def a = getBilling( o ); 
		if ( a == null ) return null; 

		def items = [];
		int idx = 0; 

		def acctGrps = a.items.groupBy{ it.txntype };
		acctGrps.each { kk,v->
			def k = [code:'', title:kk]; 
			def m = [:];
			m.item = k;
			m.amount = v.sum{it.amount};
			m.sortorder = idx++;
			m.particulars = (k.code?"("+k.code+") ":"") + k.title;
			items << m;
		} 
		return items;	
	} 

}