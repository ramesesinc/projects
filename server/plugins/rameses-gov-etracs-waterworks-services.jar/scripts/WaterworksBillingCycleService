import com.rameses.annotations.*;

import com.rameses.rules.common.*;
import waterworks.facts.*;
import treasury.facts.*;

/****************************
* calculate the date services
*****************************/
class WaterworksBillingCycleService  {
	
	@Service("RuleExecutorService")
	def ruleSvc;

	@Service("DateService")
	def dateSvc;

	@DataContext("waterworks_stubout")
	def stub;

	@DataContext("waterworks_billing_cycle")
	def billingcycle;
 
	@ProxyMethod
	public def computeBillingDates( def p ) {
		p.test = true;
		return getBillingDates( p );
	}

	@ProxyMethod
	public def getBillingDates( def p ) {

		def zone = p.zone;
		def sector = p.sector;
		def barangay = p.barangayid;

		if( !zone  ) throw new Exception("zone.objid is required");
 		if( !sector  )throw new Exception("sector.objid is required");
		
		def currDate = dateSvc.getServerDate();
		def billdate = ((p.billdate)? p.billdate : currDate); 

		def billdateinfo = dateSvc.parseDate( billdate, null ); 
		def billmonth = billdateinfo.month;
		def billyear = billdateinfo.year;  
		def m = [sectorid: sector, month: billmonth, year: billyear];

		//find billing cycle, if not exist then create
		if( !p.test ) {
			def billCycleRec = billingcycle.find( m ).first(); 
			if ( billCycleRec ) return billCycleRec; 
		}


		def facts = [];
		facts << new CurrentDate(currDate);
		facts << new BillDate( billdate );
		facts << new Stubout(zone: zone, sector: sector, barangay:barangay);
		
		//do this so it will immediately break after initial rulegroup.
		def h = { r-> return false };

		def res = ruleSvc.execute( "waterworksbillingcycle", facts, null, h );
		def period = res.period;
		if(!period) throw new Exception("No billing cycle rules executed")

		period.month = billmonth;
		period.year = billyear;
		period.sectorid = m.sectorid; 
		if(!p.test) {
			period.objid = period.sectorid + '-'+ billyear + '-'+ billmonth; 
			billingcycle.create( period ); 
		}	
		return period;
	} 
}