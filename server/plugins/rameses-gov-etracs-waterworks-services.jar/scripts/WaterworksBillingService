import com.rameses.annotations.*;

import com.rameses.rules.common.*;
import waterworks.facts.*;
import treasury.facts.*;
import com.rameses.functions.*;

class WaterworksBillingService  {
	
	@Service("RuleExecutorService")
	def ruleSvc;

	@Service("DateService")
	def dateSvc;

	@DataContext("waterworks_account")
	def acct;

	@DataContext("waterworks_application")
	def app;

	@DataContext("waterworks_account_ledger")
	def ledger;

	@DataContext("waterworks_application_fee")
	def appFee;
	
	@DataContext("waterworks_installment")
	def installment;

	@DataContext("itemaccount")
	def itemaccount;


	private def findItemAccount( def item ) {
		return itemaccount.find([objid: item.objid]).first();
	}

	//populate the impt. ids which is applicationid and acctid
	private def buildIds(def o ) {
		if(!o.applicationid && !o.appno && !o.acctid && !o.acctno )
			throw new Exception("getBilling.buildIds error.There must be an applicationid,appno,acctno, or acctid param");

		def m = [:];
		if( o.acctno ) {
			def ac = acct.find([acctno:o.acctno]).first();
			m.acctid = ac.objid;
			m.applicationid = ac.applicationid;
		}	
		else if( o.acctid ) {
			def ac = acct.find([objid:o.acctid]).first();
			m.acctid = ac.objid;
			m.applicationid = ac.applicationid;
		}
		else if( o.appno ) {
			def ap = app.find([appno:o.appno]).first();
			m.applicationid = ap.objid;
		}

		//the last should be applicationid only
		return m;
	}

	private def buildAppFees( def o, def findAcct ) {
		if(!o.applicationid) return [];
		def itemList = [];
		def fees = appFee.find([parentid: o.applicationid])
			.where("amount-amtpaid > 0 AND installmentid IS NULL").orderBy("txntype,duedate").list();
		fees.each {
			itemList << [refid: it.objid, item: findAcct(it.item), remarks: it.remarks,
				amount:it.amount-it.amtpaid, surcharge:0, interest:0, discount:0, total: it.amount-it.amtpaid];	
		}
		return itemList;
	}

	//Todo: we should call the billing ruleservice here to compute penalty
	private def buildLedgerItems( def o, def findAcct ) {
		if(!o.acctid) return [];
		def itemList = [];
		def fees = ledger.find([parentid: o.acctid])
			.where("amount-amtpaid > 0 AND installmentid IS NULL").orderBy("txntype,duedate").list();
		fees.each {
			itemList << [refid: it.objid, item: findAcct(it.item), remarks: it.remarks, duedate: it.duedate,
				amount:it.amount-it.amtpaid, surcharge:0, interest:0, discount:0, total: it.amount-it.amtpaid];	
		}
		return itemList;
	}
	
	private def buildInstallmentFees(def o, def findAcct) {
		def feeList = [];
		if(o.applicationid) {
			def fees = appFee.select("objid,item.*,amtpaid,installmentid")
				.find([parentid: o.applicationid])
				.where("amount-amtpaid > 0 AND NOT(installmentid IS NULL)").list();
			feeList.addAll( fees );
		}
		if( o.acctid ) {
			def fees = ledger.select("objid:{installmentid},item.*,installmentid,amtpaid:{SUM(amtpaid)}")
				.find([parentid: o.acctid])
				.where("amount-amtpaid > 0 AND NOT(installmentid IS NULL)")
				.groupBy("item.objid,item.code,item.title,installmentid").list();
			feeList.addAll( fees );
		}
		def itemList = [];
		feeList.each {
			def install = installment.find([objid: it.installmentid]).first();
			if(!install) throw new Exception("error buildInstallmentFees. Installmentid " + it.installmentid + " does not exist!");

			//bill only a portion of the installment.
			def monthDiff = DateFunc.monthsDiff( install.startdate, dateSvc.getServerDate() ) + 1;
			def amtdue = (install.amount / install.term) * monthDiff;  
			def remarks = "installment " + monthDiff + " of " + install.term;
			if(it.amtpaid<=0) {
				amtdue = amtdue + install.downpayment;
			}
			else {
				amtdue = amtdue - it.amtpaid;
			}
			if( amtdue > 0 ) {
				itemList << [refid: it.objid, item:findAcct(it.item), installmentid: it.installmentid,
					amount:amtdue, surcharge:0, interest:0, discount:0, total: amtdue, remarks:remarks];				
			}
		}
		return itemList;
	}

	
	@ProxyMethod
	public def getBilling( def o ) {
		def acctMap = [:];
		def findAcct = { i->
			if(!acctMap.containsKey(i.objid)) {
				def z = itemaccount.find([objid: i.objid]).first();
				if(z == null) {
					throw new Exception("Item account " + i.title + " not found!");
				}
				acctMap.put(i.objid, z);
			}
			return acctMap.get( i.objid );
		};

		def m = buildIds(o);
		def itemList = buildAppFees( o, findAcct );
		def instList = buildInstallmentFees(o, findAcct );
		def ledgerList = buildLedgerItems( o, findAcct );

		def facts = [];
		def currDate = dateSvc.getServerDate();
		facts << new EffectiveDate( currDate );
		facts << new CurrentDate(currDate);
		facts << new BillDate((!o?.billdate)?currDate:o?.billdate);
		facts << new DisconnectionDate((!o?.billdate)?currDate:o?.billdate);

		ledgerList.each {
			def acct = new Account(it.item);
			facts << new BillItem( duedate: it.duedate, account: acct, refid: it.refid, amount:it.amount, amtdue: it.amount );
		}
		def res = ruleSvc.execute( "waterworksbilling", facts, null, null );
		
		facts.findAll{ it instanceof BillItem }.each {bi->
			def g = ledgerList.find{ it.refid == bi.refid  };
			g.total = g.amount;
			if(bi.surchargeAccount ) {
				g.surcharge = bi.surcharge;
				g.surchargeAccount = bi.surchargeAccount.toItem();
				g.total += g.surcharge;
			}
			if( bi.interestAccount ) {
				g.interest = bi.interest;
				g.interestAccount = bi.interestAccount.toItem();
				g.total += g.interest;
			}
		};	
		def billItems = [];
		if(res.otherFees) {
			res.otherFees.each {
				def item = it.toItem();
				item.total = item.amount;
				billItems << item;
			}
		}
		return itemList + instList + ledgerList + billItems;
	}


	@ProxyMethod
	public def getItemizedBilling(def o) {
		def billingItems = getBilling( o );
		def items = [];
		billingItems.each { 
			items << [ item: it.item, amount: it.amount, remarks: it.remarks ];
			if( it.surcharge > 0 ) {
				items << [ item: it.surchargeAccount, amount: it.surcharge, remarks: it.remarks ];
			}
			if( it.interest > 0 ) {
				items << [ item: it.interestAccount, amount: it.interest, remarks: it.remarks ];
			}
		}
		return items;

		/*
		def items = billingItems.collect{ [ item: it.item, amount: it.amount, remarks: it.remarks ] } 
		def surchargeMap = billingItems.findAll{it.surcharge>0}.groupBy { it.surchargeAccount };
		surchargeMap.each {k,v->
			items << [ item: k, amount: v.sum{it.surcharge} ];
		}
		def interestMap = billingItems.findAll{it.interest>0}.groupBy { it.interestAccount };
		interestMap.each { k,v->
			items << [ item: k, amount: v.sum{it.interest} ];	
		}
		return items;
		*/
		
	}



}