import com.rameses.annotations.*;
import com.rameses.rules.common.*;

class WaterworksCashReceiptService  {
	
	@Service('WaterworksAccountBillingService')
	def billingService;

	@DataContext('waterworks_application')
	def waterworks_application;

	@DataContext('waterworks_account')
	def waterworks_account;

	@DataContext("collectiontype")
	def collectionType;

	@DataContext("itemaccount")
	def itemaccount;


	@ProxyMethod 
	public def getBilling( params ) { 
		def refno = params.refno; 
		def parm = [:];
		def acct = waterworks_account.find([ acctno: refno ]).first(); 
		if( acct ) {
			parm.acctid = acct.objid;
		}
		else {
			acct = waterworks_application.find([ appno: refno ]).first(); 
			if ( !acct ) throw new Exception('Reference number not found'); 
			parm.applicationid = acct.objid;
		} 

		def acc = billingService.getBilling( parm );
		if ( acc == null ) throw new Exception('There are no unpaid items'); 
		
		def p = [:];
		p.acctno = acct.acctno;
		p.paidby = acct.acctname + " (" + acct.acctno + ")"; 
		p.paidbyaddress = acct.address?.text; 
		p.payer = acct.owner; 
		p.items = [];

		def tmpitems = acc.items;

		//filter based on specified pay option
		if( params.month ) {
			int maxMonth = (params.month.year*12)+params.month.month;
			tmpitems = tmpitems.findAll{ ((it.year*12)+it.month)<=maxMonth }; 
		}

		/*
		println "counte " + tmpitems.size();
		tmpitems.each {
			println it.item.title + " " + it.year + " " + it.month + " " + it.amount;
		}
		*/

		int idx = 0;
		//separate first all watersales items
		tmpitems.findAll{ it.txntype.toString().matches('WATERSALES|ARREARS_CURRENT|ARREARS_PRIOR') }.each {
			def m = [:];
			m.item = it.item;
			m.amount = it.amount;
			m.sortorder = idx++;
			m.month = it.month;
			m.monthname = it.monthname;
			m.year = it.year;
			m.refid = it.refid;
			m.remarks = it.monthname + " " + it.year;
			m.particulars = (it.item.code?"("+it.item.code+") ": "" ) + it.item.title + " for " + m.remarks;
			p.items << m;
		}

		//we will group surcharge and interest into their respective accounts...
		def acctGrps = tmpitems.findAll{ !it.txntype.toString().matches('WATERSALES|ARREARS_CURRENT|ARREARS_PRIOR') }.groupBy{ it.item };
		acctGrps.each { k,v->
			def m = [:];
			m.item = k;
			m.amount = v.sum{it.amount};
			m.sortorder = idx++;
			m.particulars = (k.code?"("+k.code+") ":"") + k.title;
			p.items << m;
		}

		p.amount = p.items.sum{ it.amount };	

		if(parm.applicationid) p.applicationid = parm.applicationid;
		if(parm.acctid) p.acctid = parm.acctid;
		return p;
	}

}
