import com.rameses.annotations.*;
import treasury.facts.*;

class WaterworksBatchBillingInterceptor {
	
	@Service("WorkflowTaskService")
	def taskSvc;

	@Service("WaterworksScheduleService")
	def skedSvc;

	@Service("DateService")
	def dateSvc;

	@Service("WaterworksBatchBillingService")
	def batchBillingSvc;

	@DataContext("waterworks_zone")
	def zoneEm;

	@DataContext("waterworks_batch_billing")
	def batchEm;

	@DataContext("waterworks_batch_billing_task")
	def taskEm;

	@DataContext("waterworks_consumption")
	def wcEm;

	@DataContext("waterworks_billing")
	def wbillEm;

	@Before(pattern="PersistenceService.create", eval="#{ args[0]._schemaname == 'waterworks_batch_billing' }")
	public void beforeCreate( evt ) { 
		def o = evt.args[0];
		def zone = o.zone;
		def r = skedSvc.getSchedule( [year:o.year, month:o.month, scheduleid: zone.schedule.objid ] );
		o.putAll(r);
		o.schedule= zone.schedule; 
		o.objid = 'WBILL' + zone.code + o.year + String.format( "%02d", o.month);
		o.state = 'DRAFT';		
	}

	@After(pattern="PersistenceService.create", eval="#{ args[0]._schemaname == 'waterworks_batch_billing' }")
	public void buildBillItems( evt ) { 
		def o = evt.args[0];
		def result = evt.result;
		def m = [ batchid: result.objid ];

		//update the zone specifically the batchid and next billyear and month
		int ym = ((o.year*12)+o.month)+1;
		int ny = (int)(ym/12);
		int nm = (ym % 12);
		if( nm == 0 ) {
			nm = 12;
			ny = ny - 1;
		};
		def u = [nextbillyear: ny, nextbillmonth: nm, batchid: result.objid ];
		zoneEm.find( [objid: o.zone.objid] ).update( u );

		//build the consumptions first
		batchEm.buildConsumptions( m );

		//scan thru each item and assign the billing no
		def items = wcEm.find(m).orderBy("account.stuboutnode.indexno").list();

		if(!items)
			throw new Exception("No accounts processed. Please check accounts under this zone");
		int i = 1;
		items.each {
			def wb = [:];
			wb.state = 'DRAFT';
			wb.batchid = result.objid;
			wb.acctid = it.acctid;
			wb.billno = result.objid + "-" + String.format("%04d", i++);
			wb.consumptionid = it.objid;
			wb.discount = 0;
			wb.surcharge = 0;
			wb.interest = 0;
			wb.otherfees = 0;
			wb.credits = 0;
			wb.arrears = 0;
			wb.averageconsumption = 0;
			wb.unpaidmonths = 0;
			wb.billed = 0;
			wbillEm.create( wb );
		}
		def p = [:];
		p.processname = 'waterworks_batch_billing';
		p.refid = o.objid;
		p.startdate = dateSvc.serverDate;
		taskSvc.start(p);

	}

	@Before(pattern="WorkflowTaskService.signal", eval="#{ args[0].processname == 'waterworks_batch_billing' && args[0].taskstate == 'approved' && args[0].action == 'post'  }")
	public void beforePost( def evt ) {
		def p = evt.args[0];
		if(!p.refid) throw new Exception("Error WorkflowTaskService.signal post error. refid is required");
		batchBillingSvc.post([ batchid: p.refid ]);
	}

	@Before(pattern="PersistenceService.removeEntity", eval="#{ args[0]._schemaname == 'waterworks_batch_billing'}")
	void beforeRemoveEntity( evt ) {
		def p = evt.args[0]; 
		if ( batchEm.find([ objid: p.objid ]).select('task.state').val()?.state != 'draft' )
			throw new Exception('Transaction must be in draft state');  

		wbillEm.find([ batchid: p.objid ]).delete(); 
		wcEm.find( [batchid: p.objid ] ).delete();
		batchEm.find([ objid: p.objid ]).update([ taskid: '{NULL}' ]); 
		taskEm.find([ refid: p.objid ]).delete();
		zoneEm.find( [batchid: p.objid] ).update( [batchid: '{NULL}' ]);
	}

}