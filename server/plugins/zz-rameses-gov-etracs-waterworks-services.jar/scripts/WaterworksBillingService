import com.rameses.annotations.*;

import com.rameses.rules.common.*;
import waterworks.facts.*;
import treasury.facts.*;
import com.rameses.functions.*;

class WaterworksBillingService  {
	
	@Service("RuleExecutorService")
	def ruleSvc;

	@Service("DateService")
	def dateSvc;

	@DataContext("waterworks_account")
	def acct;

	@DataContext("waterworks_application")
	def app;

	@DataContext("waterworks_account_ledger")
	def ledger;

	@DataContext("waterworks_application_fee")
	def appFee;
	
	@DataContext("waterworks_installment")
	def installment;

	@DataContext("itemaccount")
	def itemaccount;

	//for billing 
	def buildBillingFacts(def facts, def o) {
		def currDate = dateSvc.getServerDate();
		facts << new EffectiveDate( currDate );
		facts << new CurrentDate(currDate);
		facts << new BillDate((!o?.billdate)?currDate:o?.billdate);
	}

	private def findItemAccount( def item ) {
		return itemaccount.find([objid: item.objid]).first();
	}

	//populate the impt. ids which is applicationid and acctid
	private def buildIds(def o ) {
		if(!o.applicationid && !o.appno && !o.acctid && !o.acctno )
			throw new Exception("getBilling.buildIds error.There must be an applicationid,appno,acctno, or acctid param");

		def m = [:];
		if( o.acctno ) {
			def ac = acct.find([acctno:o.acctno]).first();
			m.acctid = ac.objid;
			m.applicationid = ac.applicationid;
		}	
		else if( o.acctid ) {
			def ac = acct.find([objid:o.acctid]).first();
			m.acctid = ac.objid;
			m.applicationid = ac.applicationid;
		}
		else if( o.appno ) {
			def ap = app.find([appno:o.appno]).first();
			m.applicationid = ap.objid;
		}

		//the last should be applicationid only
		return m;
	}

	private def buildAppFees( def o, def findAcct ) {
		if(!o.applicationid) return [];
		def itemList = [];
		def fees = appFee.find([parentid: o.applicationid])
			.where("amount-amtpaid > 0 AND installmentid IS NULL").list();
		fees.each {
			itemList << [refid: it.objid, item: findAcct(it.item), remarks: it.remarks,
				amount:it.amount-it.amtpaid, surcharge:0, interest:0, discount:0, total: it.amount-it.amtpaid];	
		}
		return itemList;
	}

	//Todo: we should call the billing ruleservice here to compute penalty
	private def buildLedgerItems( def o, def findAcct ) {
		if(!o.acctid) return [];
		def itemList = [];
		def fees = ledger.find([parentid: o.acctid])
			.where("amount-amtpaid > 0 AND installmentid IS NULL").list();
		fees.each {
			itemList << [refid: it.objid, item: findAcct(it.item), remarks: it.remarks,
				amount:it.amount-it.amtpaid, surcharge:0, interest:0, discount:0, total: it.amount-it.amtpaid];	
		}
		return itemList;
	}
	
	private def buildInstallmentFees(def o, def findAcct) {
		def feeList = [];
		if(o.applicationid) {
			def fees = appFee.select("objid,item.*,amtpaid,installmentid")
				.find([parentid: o.applicationid])
				.where("amount-amtpaid > 0 AND NOT(installmentid IS NULL)").list();
			feeList.addAll( fees );
		}
		if( o.acctid ) {
			def fees = ledger.select("objid:{installmentid},item.*,installmentid,amtpaid:{SUM(amtpaid)}")
				.find([parentid: o.acctid])
				.where("amount-amtpaid > 0 AND NOT(installmentid IS NULL)")
				.groupBy("item.objid,item.code,item.title,installmentid").list();
			feeList.addAll( fees );
		}
		def itemList = [];
		feeList.each {
			def install = installment.find([objid: it.installmentid]).first();
			if(!install) throw new Exception("error buildInstallmentFees. Installmentid " + it.installmentid + " does not exist!");

			//bill only a portion of the installment.
			def monthDiff = DateFunc.monthsDiff( install.startdate, dateSvc.getServerDate() ) + 1;
			def amtdue = (install.amount / install.term) * monthDiff;  
			def remarks = "installment " + monthDiff + " of " + install.term;
			if(it.amtpaid<=0) {
				amtdue = amtdue + install.downpayment;
			}
			else {
				amtdue = amtdue - it.amtpaid;
			}
			if( amtdue > 0 ) {
				itemList << [refid: it.objid, item:findAcct(it.item), installmentid: it.installmentid,
					amount:amtdue, surcharge:0, interest:0, discount:0, total: amtdue, remarks:remarks];				
			}
		}
		return itemList;
	}

	
	@ProxyMethod
	public def getBilling( def o ) {
		def acctMap = [:];
		def findAcct = { i->
			if(!acctMap.containsKey(i.objid)) {
				acctMap.put(i.objid, itemaccount.find([objid: i.objid]).first());
			}
			return acctMap.get( i.objid );
		};

		def m = buildIds(o);
		def itemList = buildAppFees( o, findAcct );
		def instList = buildInstallmentFees(o, findAcct );
		def ledgerList = buildLedgerItems( o, findAcct );

		return itemList + instList + ledgerList;

		/*
		def ledgerFacts = buildLedgerFacts(o);
		def res = ruleSvc.execute( "waterworksbilling", appFacts + ledgerFacts, null, null );
		if( res.billItemList)
			throw new Exception("No compute fee rules executed");
		return res.billItemList.buildBillItems();
		*/
	}



}