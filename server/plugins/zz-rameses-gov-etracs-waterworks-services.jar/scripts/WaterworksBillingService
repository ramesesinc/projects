import com.rameses.annotations.*;

import com.rameses.rules.common.*;
import waterworks.facts.*;
import treasury.facts.*;
import treasury.actions.*;

class WaterworksBillingService {
	
	@Service("RuleExecutorService")
	def ruleSvc;

	@DataContext("collectiontype")
	def colType;

	@DataContext("collectiontype_account")
	def colTypeAcct;


	@Service("DateService")
	def dateSvc;

	@DataContext("waterworks_account")
	def acct;

	@DataContext("waterworks_account_consumption")
	def wac;

	@DataContext("itemaccount")
	def itemAcct;

 	def monthList = ["JAN","FEB","MAR","APR","MAY","JUN","JUL","AUG","SEP","OCT","NOV","DEC"];

	//for billing 
	def buildBillingFacts(def facts, def o) {
		def currDate = dateSvc.getServerDate();
		facts << new EffectiveDate( currDate );
		facts << new CurrentDate(currDate);
		facts << new BillDate((!o?.billdate)?currDate:o?.billdate);
	}

	def buildActions(def res) {
		def ra = new RuleAction();
		ra.addCommand( "set-duedate", new SetDueDate(res: res)); 
		ra.addCommand( "set-billitem-duedate", new SetBillItemDueDate(res: res)); 
		ra.addCommand( "compute-discount", new ComputeDiscount(res: res)); 
		ra.addCommand( "compute-surcharge", new ComputeSurcharge(res:res));
		ra.addCommand( "compute-interest", new ComputeInterest(res:res));
		return ra;
	}

	//find the waterworks account by acctno or by objid
	def findAccount(def o) {
		def p = null;    
		if( o.objid ) {
			p = [objid: o.objid];
		}
		else if(o.acctno) {
			p = [acctno:o.acctno];
		}
		if(!p )
		    throw new Exception('Please specify objid or acctno');
		def m = acct.find( p ).first();
		if( !m ) 
			throw new Exception("Waterworks account not found");
		return m;	
	}

	//find the waterworks item account used. This is defined in the collection type
	def findItemAccount( def o ) {
	    if(!o.tag) throw new Exception('Please specify tag whether BASIC, SURCHARGE or PENALTY');	
	    def wct = colType.find( [handler: 'waterworks'] ).first();
	    if(!wct)
		throw new Exception( "Collection type handler waterworks not found"  );
	    def wctacct = colTypeAcct.find( [collectiontypeid: wct.objid, tag: o.tag] ).first();
	    if(!wctacct) throw new Exception( 'water account specified with tag ' + o.tag + ' not defined in collection type waterworks' )

	    def revItem = itemAcct.find([objid:wctacct.account.objid]).first();
	    if( !revItem )
		throw new Exception("Revneue Item Account not found" );
	    return revItem;  	
	} 

	@ProxyMethod
	public def processBilling( def feeList ) {
		
		//setup resource  
		def res = [:];
		res.billItemList = new BillItemList();

		def itemAcct = findItemAccount( [tag: 'BASIC' ] ); 
		

		//build the facts   
		def facts = [];
		feeList.each {
			def bi = new WaterBillItem();
			bi.refid = it.objid;
			bi.item = it;
			bi.account = new Account(itemAcct);
			bi.year = it.year;
			bi.month = it.month;
			bi.smonth = monthList[it.month-1];
			bi.reading = it.reading;
			bi.prevreading = it.prevreading;
			bi.volume = it.volume;
			bi.amount = it.amount - it.amtpaid;
			bi.amtdue = bi.amount;
			bi.sortorder = (it.year*100)+it.month;
			res.billItemList.addItem( bi );
			facts.add( bi );
		}
		buildBillingFacts( facts, null );
		def zactions = buildActions(res);	

		ruleSvc.execute( "waterworksbilling", facts, zactions, null );
		def list = res.billItemList.buildBillItems();
		return list;
	}




	/***********************************************************************
	* this is called by other services. This returns the billing head 
	* and its items
	***********************************************************************/
	@ProxyMethod
	public def getBilling( def o ) {
		//get the head. then get the receivables
		def app = findAccount( o );
		def feeList = wac.find([acctid: app.objid]).where('amount - amtpaid > 0').list();	
		if(!feeList)
		   throw new Exception("There are no upaid items for this account");


		def itemAcct = findItemAccount( [tag: 'BASIC' ] ); 
		
		//setup resource  
		def res = [:];
		res.billItemList = new BillItemList();

		//build the facts   
		def facts = [];
		facts << new WaterAccount(app);
		feeList.each {
			def bi = new WaterBillItem();
			bi.refid = it.objid;
			bi.item = it;
			bi.account = new Account(itemAcct);
			bi.year = it.year;
			bi.month = it.month;
			bi.smonth = monthList[it.month-1];
			bi.volume = it.volume;
			bi.amount = it.amount - it.amtpaid;
			bi.amtdue = bi.amount;
			bi.sortorder = (it.year*100)+it.month;
			res.billItemList.addItem( bi );
		}
		facts.addAll( res.billItemList.items ); 
		
		buildBillingFacts( facts, o );
		def actions = buildActions(res);

		//check if there is payment option, use this handler 
		//if the payoption is partial
		def handler = { n->
			if( n == 'payment') {
				//for partial payment 
				res.monthList = res.billItemList.items.collect { [month:it.month, year:it.year, smonth:it.smonth] };
				if(o.payOption?.type=='PARTIAL') {
					res.billItemList.applyPayment(  o.payOption.amount );
				}
				else if(o.payOption?.type=='MONTH') {
					def mm = o.payOption.month;
					res.billItemList.items = res.billItemList.items.findAll{  
						return ((it.year * 100)+it.month) <=  ((mm.year*100)+mm.month) 
					};
				} 
			}
		}

		ruleSvc.execute( "waterworksbilling", facts, actions, handler );
		app.billitems = res.billItemList.buildBillItems();
		app.items = res.billItemList.buildReceiptItems();
		app.amount = app.items.sum{ it.amount };
		app.monthList = res.monthList;
		return app;
	}


}