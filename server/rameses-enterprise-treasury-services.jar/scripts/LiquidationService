import com.rameses.annotations.*;
import com.rameses.util.*;
import java.rmi.server.*;
import com.rameses.common.*
import com.rameses.services.extended.*;


class LiquidationService  {

	@Env
	def env;

	@Service("SequenceService")
	def seqSvc;

	@Service("DateService")
	def dateSvc;

	@Service("Var")
	def var;

	@DataContext("liquidation")
	def liqEm;
	
	@DataContext("liquidation_fund")
	def liqfund;

	@DataContext("liquidation_noncashpayment")
	def liqnoncash;

	@DataContext("remittance")
	def rem_db;

	@DataContext("remittance_fund")
	def remf_db;


	@ProxyMethod
	public def init() {
		/*if( ! toBoolean(var.allow_multiple_open_liquidation, true)) {
			def ud = em.getUndepositedLiquidations([liquidatingofficerid: env.USERID] ) 
			if(ud ) throw new Exception("There are still undeposited liquidations. ");	
		}*/

		def temptxnno = com.rameses.util.Encoder.MD5.encode( env.USERID ); 
		def draftdata = liqEm.find([ txnno: temptxnno ]).first(); 
		if ( draftdata ) throw new Exception("""  
			You still have a DRAFT liquidation that was previously created.  
		""");


		def m = [ state:'DRAFT', posted:0, cashbreakdown:[], remittances:[], funds:[] ];
		m.liquidatingofficer = [objid:env.USERID, name:env.FULLNAME, title: env.JOBTITLE ];
		m.txndate = dateSvc.serverDate;
		m.dtposted = m.txndate;
		m.txnno = temptxnno;
		m.totalcr = 0.0;
		m.totalcash = 0.0;
		m.totalcheck = 0.0; 
		m.amount = 0.0;
		m = liqEm.create( m ); 

		def liqparam = [ liquidationid: m.objid, liquidatingofficerid: env.USERID ]; 
		liqEm.bindRemittances( liqparam ); 
		liqparam.remove('liquidatingofficerid');
		
		if ( !rem_db.find( liqparam ).first() ) 
			throw new Exception("No pending remittances to liquidate"); 

		liqEm.insertFunds( liqparam ); 
		liqEm.insertNonCashPayments( liqparam );	
		liqEm.bindRemittanceFunds( liqparam );	

		def totalcbs = [];
		def liqfundlist = liqfund.find( liqparam ).list();
		liqfundlist.each{ 
			def cbs = [];
			remf_db.find([ liquidationfundid: it.objid ]).select('cashbreakdown').list().each{ oi-> 
				if ( oi.cashbreakdown ) cbs.addAll( oi.cashbreakdown ); 
			}

			def newcbs = []; 
			cbs.groupBy{ it.denomination }.each{ k,v-> 
				newcbs << [ 
					caption:k, denomination:k, 
					qty: v.sum{( it.qty? it.qty: 0 )}, 
					amount: v.sum{( it.amount ? it.amount : 0.0 )} 
				]; 
			} 
			
			it.cashbreakdown = newcbs; 
			liqfund.find([ objid: it.objid ]).update([ cashbreakdown: it.cashbreakdown ]);  
			totalcbs.addAll( it.cashbreakdown ); 
		} 

		m.cashbreakdown = []; 
		totalcbs.groupBy{ it.denomination }.each{ k,v-> 
			m.cashbreakdown << [ 
				caption:k, denomination:k, 
				qty: v.sum{( it.qty? it.qty: 0 )}, 
				amount: v.sum{( it.amount ? it.amount : 0.0 )} 
			]; 
		} 
		totalcbs.clear(); 

		def amount=0.0; def totalcr=0.0; def totalcash=0.0; def totalcheck=0.0;
		liqfundlist.each{ 
			amount += ( it.amount ? it.amount : 0.0 ); 
			totalcr += ( it.totalcr ? it.totalcr : 0.0 ); 
			totalcash += ( it.totalcash ? it.totalcash : 0.0 ); 
			totalcheck += ( it.totalcheck ? it.totalcheck : 0.0 ); 
		} 
		m.amount = amount;
		m.totalcr = totalcr; 
		m.totalcash = totalcash; 
		m.totalcheck = totalcheck; 
		liqEm.find([ objid: m.objid ]).update([ 
			amount        : m.amount, 
			totalcr       : m.totalcr, 
			totalcash     : m.totalcash, 
			totalcheck    : m.totalcheck, 
			cashbreakdown : m.cashbreakdown 
		]); 

		return open([ objid: m.objid ]); 
	}

	@ProxyMethod
	public def open( params ) { 
		def o = liqEm.find([ objid: params.objid ]).first(1);
		if ( o.liquidatingofficer?.signature ) {
			Base64Cipher cipher = new Base64Cipher()
			o.liquidatingofficer.signature = cipher.decode( o.liquidatingofficer.signature );
		}
		if ( o.cashier?.signature ) {
			Base64Cipher cipher = new Base64Cipher()
			o.cashier.signature = cipher.decode( o.cashier.signature );
		}

		o.totalcash = o.totalcheck = o.totalcr = 0.0; 
		o.funds.each{
			o.totalcr += ( it.totalcr ? it.totalcr : 0.0 );
			o.totalcash += ( it.totalcash ? it.totalcash : 0.0 );
			o.totalcheck += ( it.totalcheck ? it.totalcheck : 0.0 );
		}
		o.totalnoncash = o.totalcheck + o.totalcr; 

		def liqparam = [ liquidationid: o.objid ];
		o.fundsummary = o.remove('funds');
		o.creditmemos = [];
		o.checks = [];
		liqnoncash.find( liqparam ).list().each{
			def a = [ objid: it.objid, liquidationid: o.objid ];
			if ( it.payment ) a.putAll( it.payment ); 
			if ( a.reftype == 'CREDITMEMO' ) o.creditmemos << a; 
			else o.checks << a; 
		} 
		return o; 
	} 

	@ProxyMethod
	public def post( param ) { 
		if ( !param.objid ) throw new Exception("objid parameter is required"); 

		def o = liqEm.find([ objid: param.objid ]).first(); 
		if ( !o ) throw new Exception('Liquidation record does not exist.');
		if ( o.state != 'DRAFT' ) throw new Exception("Liquidation record is no longer in DRAFT mode");

		o.dtposted = dateSvc.getServerDate(); 
		o.state = 'POSTED'; 
		o.txnno = formatTxnno( o ); 
		liqEm.find([ objid: o.objid ]).update([ state: o.state, txnno: o.txnno, dtposted: o.dtposted ]); 
		liqEm.updateFundControlNo([ liquidationid: o.objid ]); 

		rem_db.find([ liquidationid: o.objid ]).update([ state: 'CLOSED' ]); 
		return o; 
	} 

	@ProxyMethod 
	public def getChecks( params ) {
		return liqEm.getChecks([ liquidationid: params.objid ]); 
	}

	@ProxyMethod
	public def getFundSummaries(o) {
		return em.getFundSummaries([ liquidationid: o.objid ]);
	}


	@ProxyMethod
    public void approve(def o) {
    	def m = [ state: 'APPROVED' ];
    	liqEm.find( [objid : o.objid] ).update( m );
    } 



	@ProxyMethod
    public def formatTxnno( liq ) {
    	def format = 'UTFS'
    	def seqid = null
    	if(var.liquidation_format) format = var.liquidation_format;
    	if(var.liquidation_sequenceid_format ) seqid = var.liquidation_sequenceid_format;
    	

        //Formatting Options:
        // YY - YEAR POSTED
        // MM - MONTH POSTED 
        // DD - DATE POSTED 
        // UT - USER TXNCODE
        // SQ - SEQUENCE 
        // FS- FORMATTED SEQUENCE 
        
        def dt = dateSvc.parseDate( liq.dtposted, null)
        def txncode = "LIQ";	
		if(env.TXNCODE) txncode = "LIQ-" + env.TXNCODE; 		

        def values = [
        	YY:dt.year+"", 
        	MM:dt.month.toString().padLeft(2, '0',),
        	DD:dt.day.toString().padLeft(2, '0'),
        	UT:txncode 
        ]

        def txnno  = format 
        values.keySet().each {
            txnno = txnno.replace( it, values[it] )
        }

        def series 
        if(seqid) {
        	def seq = seqid;
        	values.keySet().each {
            	seq = seq.replace( it, values[it] )
            }
            series = seqSvc.getNextSeries( seq); 
            
        } else {
        	series = seqSvc.getNextSeries(  txnno.replace("FS", '') ); 
        }

        txnno = txnno.replace( 'SQ', series+"" )
        txnno = txnno.replace( 'FS', "$series".padLeft(5, '0') )
        return txnno 
    }

    public boolean toBoolean(value, defvalue){
        if (value == null) 
            return defvalue;

        if (value instanceof Boolean) 
            return value;

        if ('1/y/yes/t/true'.indexOf(value.toString().trim()) >= 0 ) 
            return true;
        
        return false;
    }    
}	