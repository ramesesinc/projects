import com.rameses.annotations.*;
import com.rameses.common.*;
import com.rameses.util.*;

class RemittanceService  {

	@ActiveDB("remittance")
	def em; 

	@ActiveDB("remittance_tool")
	def remittance_tool; 

	@Env
	def env;

	@Service 
	def self; 

	@Service("SequenceService")
	def seqSvc;

	@Service("DateService")
	def dateSvc;

	@Service("CashBookPostService")
	def cashBook;
	
	@Service("Var")
	def var;

	@DataContext("remittance")
	def remdb;

	@DataContext("remittance_fund")
	def remf_db;

	@DataContext("remittance_af")
	def remaf_db;

	@DataContext("remittance_noncashpayment")
	def rem_noncash;

	@DataContext("af_control")
	def afc_db;

	@DataContext('cashreceipt') 
	def cashreceipt_db;

	@ProxyMethod
	public def init( param ) { 
		boolean split_txn = (var.remittance_split_transaction.toString().matches('false|0') ? false : true); 

		def temptxnno = com.rameses.util.Encoder.MD5.encode( env.USERID ); 
		def draftdata = remdb.find([ txnno: temptxnno ]).first(); 
		if ( draftdata ) throw new Exception("""  
			You still have a DRAFT remittance that was previously created.  
		""");

		def rundate = dateSvc.getServerDate(); 
		def remittanceid = "REM" + new java.rmi.server.UID(); 
		def o = [ objid: remittanceid, state:'DRAFT', txnno: temptxnno, dtposted: rundate ]; 
		o.collector = [ objid: env.USERID, name: env.FULLNAME, title: env.JOBTITLE ]; 
		o.remittancedate = new java.sql.Date( rundate.time );
		o.amount = o.totalcash = o.totalnoncash = 0.0; 
		o.cashbreakdown = [];
		remdb.create( o );  

		def hasPrevMonthTrxns = false; 
		def info = [ remittanceid: remittanceid, collectorid: env.USERID ];
		if ( split_txn ) {
			info.txndate = getMonthFirstDate( rundate ); 
			remdb.updateSerialReceipts( info );  
			remdb.updateNonSerialReceipts( info );  
			def test = cashreceipt_db.find([ remittanceid: remittanceid ]).first(); 
			if ( test ) { 
				o.endofmonth = true; 
				o.message = "End of the month remittance only. Please remit again for the remaining collection."; 
				o._txndate = info.txndate; 
				hasPrevMonthTrxns = true; 
			} 
		} 
		
		if ( !hasPrevMonthTrxns ) {
			info.txndate = dateSvc.serverDate; 
			remdb.updateSerialReceipts( info ); 
			remdb.updateNonSerialReceipts( info ); 
			o._txndate = dateSvc.format('yyyy-MM-dd HH:mm:ss', info.txndate);
		} 

		o.items = remdb.getBuildReceiptSummary( info );  
		if ( !o.items ) throw new Exception("No collections to be remitted.   ");

		remdb.insertNonCashPayment( info ); 
		remdb.insertFundSummary( info ); 

		remdb.getBuildCancelSeries( info ).groupBy{ it.controlid }.each{ k,v-> 
			def afc = o.items.find{ it.controlid == k } 
			afc.cancelSeriesList = v; 
		}

		o.checks = remdb.getNonCashPayments( info );

		o.amount = 0;
		o.totalcash = 0;
		o.totalnoncash = 0;
		if ( o.items ) { 
			o.amount = o.items.sum{( it.amount ? it.amount : 0.0 )} 
			o.totalcash = o.items.sum{( it.totalcash ? it.totalcash : 0.0 )} 
			o.totalnoncash = o.items.sum{( it.totalnoncash ? it.totalnoncash : 0.0 )} 
		} 

		remdb.find([ objid: remittanceid ]).update([ 
			amount: o.amount, totalcash: o.totalcash, totalnoncash: o.totalnoncash 
		]); 

		def afcs = afc_db.find([ owner_objid: o.collector.objid ]).where(' currentseries <= endseries ').list(); 
		afcs.each{ it.controlid=it.objid } 


		def rafparam = [ txndate: o.dtposted ]; 
		rafparam.controls = afcs.collect{ it.objid } 
		rafparam.controls.addAll( o.items.collect{ it.controlid } ); 
		rafparam.controls = rafparam.controls.unique().collect{[ controlid: it ]} 

		def rafs = self.getBuildAF( rafparam ); 
		rafs.each{ a-> 
			def b = o.items.find{ it.controlid==a.controlid } 
			if ( !b ) return; 

			if ( b.formtype=='serial' ) {
				a.qtycancelled = b.cqty;
				a.qtyissued = b.qty; 
				a.issuedendseries = b.endseries; 
				a.issuedstartseries = b.startseries; 
				a.endingstartseries = a.issuedendseries+1; 
				a.endingendseries = b.afendseries;
			} else if ( b.formtype=='cashticket' ) { 
				def currentseries = b.afstartseries;
				def qty = (int) ( b.amount / b.denomination ); 
				def cts = remdb.getRemittedCashTickets([ controlid: a.controlid ]); 
				cts = cts.findAll{ it.remittanceid != remittanceid } 
				if ( cts ) {
					currentseries = ((int) (cts.sum{( it.amount ? it.amount : 0.0 )} / b.denomination)) + b.afstartseries; 
				} 
				a.issuedstartseries = currentseries; 
				a.issuedendseries = (currentseries + qty)-1; 
				a.qtyissued = qty; 
				a.endingstartseries = a.issuedendseries+1;
				a.endingendseries = b.afendseries;
			}

			if ( a.endingstartseries > b.afendseries ) {
				a.endingstartseries = a.endingendseries = null; 
				a.qtyending = 0; 
			} else {
				a.qtyending = (a.endingendseries - a.endingstartseries)+1; 
			} 
		}

		rafs.each{ 
			it.objid = 'REMAF-'+ new java.rmi.server.UID(); 
			it.remittanceid = remittanceid; 
			remaf_db.create( it ); 
		} 
		return o; 
	} 

	@ProxyMethod 
	public def getBuildAF( afcs ) {
		return []; 
	} 

	@ProxyMethod 
	public def post( param ) { 
		if ( !param.remittanceid ) throw new Exception("remittanceid parameter is required"); 

		def o = remdb.find([ objid: param.remittanceid ]).first(); 
		if ( !o ) throw new Exception('Remittance record does not exist.');
		if ( o.state != 'DRAFT' ) throw new Exception("Remittance record is no longer in DRAFT mode");

		// check cashbreakdown per fund 
        def cblist = remf_db.find([ remittanceid: o.objid ]).select("cashbreakdown,fund.*").where(" totalcash > 0 ").list();
        cblist.each { 
        	def amt = it.cashbreakdown?.sum{( it.amount ? it.amount: 0.0 )} 
        	if ( !amt ) throw new Exception('Please specify a cashbreakdown for fund '+ it.fund.title ); 

        	def diff = (o.totalcash - amt);
	        if( diff  > 0.05 )
	            throw new Exception("Cash to remit is insufficient. Please review your collection for " + it.fund.title);
	        if( diff < -0.05 )
	            throw new Exception("Please review your collection. You have over declared the cash breakdown for " + it.fund.title);
        }

		param.cashbreakdown = summarizeFundCashbreakdown( o.objid ); 

		o.state = 'OPEN'; 
		o.txnno = formatTxnno( o ); 
		if ( !o.collector ) o.collector = [:];
		if ( param.collector?.signature ) o.collector.signature = param.collector.signature; 

		remdb.find([ objid: param.remittanceid ]).update([ 
			cashbreakdown: param.cashbreakdown, 
			txnno: o.txnno, state: o.state, 
			collector: o.collector 
		]); 

		return o; 
	} 

	@ProxyMethod
	public def open( o ) {
		o = remdb.read( o );
		o.remittanceid = o.objid; 
		return o;
	}

	

	public def getMonthFirstDate( dt ) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(dt);
        cal.set( Calendar.DAY_OF_MONTH, 1 );
        return dateSvc.format('yyyy-MM-dd', cal.getTime()) + " 00:00:00";
    }

    @ProxyMethod
    public def formatTxnno( remittance ) {
    	def format = 'UTFS'
    	def seqid = null
    	if(var.remittance_format) format = var.remittance_format;
    	if(var.remittance_sequenceid_format ) seqid = var.remittance_sequenceid_format;
    	

        //Formatting Options:
        // YY - YEAR POSTED
        // MM - MONTH POSTED 
        // DD - DATE POSTED 
        // UT - USER TXNCODE
        // SQ - SEQUENCE 
        // FS - FORMATTED SEQUENCE 
        
        def txncode = ["REM", env.TXNCODE, env.ORGTXNCODE].findAll{( it )}.join("-");
        def dt = dateSvc.parseDate( remittance.dtposted, null); 
        def values = [ 
        	YY:dt.year+"", 
        	MM:dt.month.toString().padLeft(2, '0',),
        	DD:dt.day.toString().padLeft(2, '0'),
        	UT:txncode 
        ];

        def txnno = format;  
        values.keySet().each {
            txnno = txnno.replace( it, values[it] )
        }

        def series; 
        if ( seqid ) { 
        	def seq = seqid;
        	values.keySet().each {
            	seq = seq.replace( it, values[it] )
            }
            series = seqSvc.getNextSeries( seq); 
            
        } else { 
        	series = seqSvc.getNextSeries(  txnno.replace("FS", '') ); 
        }

        txnno = txnno.replace( 'SQ', series+"" );
        txnno = txnno.replace( 'FS', "$series".padLeft(5, '0')); 
        return txnno; 
    }

    @ProxyMethod 
    public void revert( params ) {
    	if ( !params.objid ) throw new Exception('objid parameter is required'); 

    	params.remittanceid = params.objid; 
    	def o = remittance_tool.findRemittance( params ); 
    	if ( o?.liquidated > 0 ) 
    		throw new Exception('This transaction has already been liquidated. Cannot revert remittance'); 

    	remittance_tool.removeFunds( params ); 
    	remittance_tool.removeAFs( params ); 
    	remittance_tool.removeCashReceipts( params ); 
    	remittance_tool.removeCreditMemoPayments( params ); 
    	remittance_tool.removeNonCashPayments( params ); 
    	remittance_tool.removeRemittance( params ); 
    } 

    @ProxyMethod
    public void approve( o ) {
    	def m = [state: 'APPROVED' ];
    	m.liquidatingofficer = [ objid:env.USERID, name:env.FULLNAME, title:env.JOBTITLE ]; 
    	remdb.find([ objid : o.objid ]).update( m ); 
    } 


    //LISTS THAT WILL BE RETRIEVED BY REMITTANCE
	@ProxyMethod
	public def getRemittedReceipts( o ) { 
		return em.getRemittedReceipts( o );
	}

    @ProxyMethod
    public def getRemittanceFunds( def o ) {
    	return remf_db.find( [remittanceid: o.remittanceid ] ).list();
    }

	@ProxyMethod
    public def getCashBreakdown( def o ) {
    	def r = remdb.find( [objid: o.objid ] ).select("cashbreakdown").val();
    	return r;
    }

	@ProxyMethod
    public def getFundCashBreakdown( def o ) {
    	def r = remf_db.find( [objid: o.objid ] ).select("cashbreakdown").val();
    	return r;
    }

 	@ProxyMethod
    public def getRemittanceChecks( def o ) {
    	//check if there is fund provided
    	def cond  = [];
    	def parm = [:];

		cond << " ref.reftype = 'CHECK' " 
    	def xem = rem_noncash.find( [remittanceid: o.remittanceid ] );
    	if( o.fund ) {
    		cond << "ref.fund.objid = :fundid";
    		parm.fundid = o.fund.objid;
    	}
    	return xem.where(cond.join(" AND "), parm).list()*.ref;
    }

 	@ProxyMethod
    public def getRemittanceCreditMemos( def o ) {
    	//check if there is fund provided
    	def cond  = [];
    	def parm = [:];

		cond << " NOT( ref.reftype = 'CHECK') " 
    	def xem = rem_noncash.find( [remittanceid: o.remittanceid ] );
    	if( o.fund ) {
    		cond << "ref.fund.objid = :fundid";
    		parm.fundid = o.fund.objid;
    	}
    	return xem.where(cond.join(" AND "), parm).list()*.ref;
    }

    @ProxyMethod
    public void updateCashBreakdown( o ) { 
        def m = remf_db.find([ objid: o.objid ]).select('objid,remittanceid').first(); 
        if ( !m ) return;

        remf_db.find([ objid: m.objid ]).update([ cashbreakdown: o.cashbreakdown ]);  

		def totalcbd = summarizeFundCashbreakdown( m.remittanceid ); 
		remdb.find([ objid: m.remittanceid ]).update([ cashbreakdown: totalcbd ]);
    } 

    private def summarizeFundCashbreakdown( remittanceid ) {
        def arr = [];
        def cblist = remf_db.find([ remittanceid: remittanceid ]).select("cashbreakdown").where(" totalcash > 0 ").list();
        cblist.each { 
        	if ( it.cashbreakdown ) arr.addAll( it.cashbreakdown ); 
        }

        def newarr = [];
        arr.groupBy{ it.denomination }.each { k,v->
        	newarr << [ caption:k, denomination:k, qty: v.sum{it.qty}, amount: v.sum{it.amount} ];	
        }
        return newarr; 
    }
}