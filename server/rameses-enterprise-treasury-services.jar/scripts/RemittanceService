import com.rameses.annotations.*;
import com.rameses.common.*;
import com.rameses.util.*;

class RemittanceService  {

	@ActiveDB("remittance")
	def em; 

	@ActiveDB("remittance_tool")
	def remittance_tool; 

	@Env
	def env;

	@Service 
	def self; 

	@Service("SequenceService")
	def seqSvc;

	@Service("DateService")
	def dateSvc;

	@Service("CashBookPostService")
	def cashBook;
	
	@Service("Var")
	def var;

	@DataContext("remittance")
	def remdb;

	@DataContext("remittance_cashreceipt")
	def remc_db;

	@DataContext("remittance_fund")
	def remf_db;

	@DataContext("remittance_af")
	def remaf_db;

	@DataContext("af_control")
	def afc_db;

	@ProxyMethod
	public def init( param ) { 
		boolean split_txn = (var.remittance_split_transaction.toString().matches('false|0') ? false : true); 

		def temptxnno = com.rameses.util.Encoder.MD5.encode( env.USERID ); 
		def draftdata = remdb.find([ txnno: temptxnno ]).first(); 
		if ( draftdata ) throw new Exception("""  
			You still have a DRAFT remittance that was previously created.  
		""");

		def rundate = dateSvc.getServerDate(); 
		def remittanceid = "REM" + new java.rmi.server.UID(); 
		def o = [ objid: remittanceid, state:'DRAFT', txnno: temptxnno, dtposted: rundate ]; 
		o.collector = [ objid: env.USERID, name: env.FULLNAME, title: env.JOBTITLE ]; 
		o.remittancedate = new java.sql.Date( rundate.time );
		o.amount = o.totalcash = o.totalnoncash = 0.0; 
		o.cashbreakdown = [];
		remdb.create( o );  

		def hasPrevMonthTrxns = false; 
		def info = [ remittanceid: remittanceid, collectorid: env.USERID ];
		if ( split_txn ) {
			info.txndate = getMonthFirstDate( rundate ); 
			remdb.insertSerialReceipts( info );  
			remdb.insertCashTickets( info );  
			def test = remc_db.find([ remittanceid: remittanceid ]).first(); 
			if ( test ) { 
				o.endofmonth = true; 
				o.message = "End of the month remittance only. Please remit again for the remaining collection."; 
				o._txndate = info.txndate; 
				hasPrevMonthTrxns = true; 
			} 
		} 
		
		if ( !hasPrevMonthTrxns ) {
			info.txndate = dateSvc.serverDate; 
			remdb.insertSerialReceipts( info ); 
			remdb.insertCashTickets( info ); 
			o._txndate = dateSvc.format('yyyy-MM-dd HH:mm:ss', info.txndate);
		} 

		o.items = remdb.getBuildReceiptSummary( info );  
		if ( !o.items ) throw new Exception("No collections to be remitted.   ");

		remdb.insertNonCashPayment( info ); 
		remdb.getBuildFundSummary( info ).each{ rf-> 
			rf.objid = 'REMF-'+ new java.rmi.server.UID(); 
			remf_db.create( rf ); 
		} 

		remdb.getBuildCancelSeries( info ).groupBy{ it.controlid }.each{ k,v-> 
			def afc = o.items.find{ it.controlid == k } 
			afc.cancelSeriesList = v; 
		}

		o.checks = remdb.getNonCashPayments( info );

		o.amount = 0;
		o.totalcash = 0;
		o.totalnoncash = 0;
		if ( o.items ) { 
			o.amount = o.items.sum{( it.amount ? it.amount : 0.0 )} 
			o.totalcash = o.items.sum{( it.totalcash ? it.totalcash : 0.0 )} 
			o.totalnoncash = o.items.sum{( it.totalnoncash ? it.totalnoncash : 0.0 )} 
		} 

		remdb.find([ objid: remittanceid ]).update([ 
			amount: o.amount, totalcash: o.totalcash, totalnoncash: o.totalnoncash 
		]); 

		def afcs = afc_db.find([ owner_objid: o.collector.objid ]).where(' currentseries <= endseries ').list(); 
		afcs.each{ it.controlid=it.objid } 


		def rafparam = [ txndate: o.dtposted ]; 
		rafparam.controls = afcs.collect{ it.objid } 
		rafparam.controls.addAll( o.items.collect{ it.controlid } ); 
		rafparam.controls = rafparam.controls.unique().collect{[ controlid: it ]} 

		def rafs = self.getBuildAF( rafparam ); 
		rafs.each{ a-> 
			def b = o.items.find{ it.controlid==a.controlid } 
			if ( !b ) return; 

			if ( b.formtype=='serial' ) {
				a.qtycancelled = b.cqty;
				a.qtyissued = b.qty; 
				a.issuedendseries = b.endseries; 
				a.issuedstartseries = b.startseries; 
				a.endingstartseries = a.issuedendseries+1; 
				a.endingendseries = b.afendseries;
			} else if ( b.formtype=='cashticket' ) { 
				def currentseries = b.afstartseries;
				def qty = (int) ( b.amount / b.denomination ); 
				def cts = remdb.getRemittedCashTickets([ controlid: a.controlid ]); 
				cts = cts.findAll{ it.remittanceid != remittanceid } 
				if ( cts ) {
					currentseries = ((int) (cts.sum{( it.amount ? it.amount : 0.0 )} / b.denomination)) + b.afstartseries; 
				} 
				a.issuedstartseries = currentseries; 
				a.issuedendseries = (currentseries + qty)-1; 
				a.qtyissued = qty; 
				a.endingstartseries = a.issuedendseries+1;
				a.endingendseries = b.afendseries;
			}

			if ( a.endingstartseries > b.afendseries ) {
				a.endingstartseries = a.endingendseries = null; 
				a.qtyending = 0; 
			} else {
				a.qtyending = (a.endingendseries - a.endingstartseries)+1; 
			} 
		}

		rafs.each{ 
			it.objid = 'REMAF-'+ new java.rmi.server.UID(); 
			it.remittanceid = remittanceid; 
			remaf_db.create( it ); 
		} 
		return o; 
	} 

	@ProxyMethod 
	public def getBuildAF( afcs ) {
		return []; 
	} 

	@ProxyMethod 
	public def post( param ) { 
		if ( !param.remittanceid ) throw new Exception("remittanceid parameter is required"); 
		if ( !param.cashbreakdown ) throw new Exception("Cash breakdown has been change during the submission.Please recreate transaction");

		def o = remdb.find([ objid: param.remittanceid ]).first(); 
		if ( o.state != 'DRAFT' ) throw new Exception("Remittance record is no longer in DRAFT mode");

		o.state = 'OPEN'; 
		o.txnno = formatTxnno( o ); 
		remdb.find([ objid: param.remittanceid ]).update([ 
			cashbreakdown: param.cashbreakdown, 
			txnno: o.txnno, 
			state: o.state 
		]); 
		return o; 
	} 

	@ProxyMethod
	public def open( o ) {
		o = em.read( o );
		o.remittanceid = o.objid; 

		Base64Cipher cipher = new Base64Cipher()
		if( o.collector?.signature !=null ) {
			o.signature = cipher.decode( o.collector.signature );
		}
		if(o.liquidatingofficer?.signature) {
			o.liquidatingofficer.signature =  cipher.decode(o.liquidatingofficer.signature)
		}

		o.checks = em.getRemittedChecks( o ); 

		def td = o.checks.findAll{ it.reftype == 'CHECK' }?.sum{it.amount};
		if(td==null) td = 0.0;

		def tc = o.checks.findAll{ it.reftype == 'CREDITMEMO' }?.sum{it.amount};
		if(tc==null) tc = 0.0;

		o.totaldeposit = td + o.totalcash;
		o.totalcreditmemo = tc;
		return o;
	}

	@ProxyMethod
	public def getRemittedReceipts( o ) { 
		return em.getRemittedReceipts( o );
	}

	public def getMonthFirstDate( dt ) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(dt);
        cal.set( Calendar.DAY_OF_MONTH, 1 );
        return dateSvc.format('yyyy-MM-dd', cal.getTime()) + " 00:00:00";
    }

    @ProxyMethod
    public def formatTxnno( remittance ) {
    	def format = 'UTFS'
    	def seqid = null
    	if(var.remittance_format) format = var.remittance_format;
    	if(var.remittance_sequenceid_format ) seqid = var.remittance_sequenceid_format;
    	

        //Formatting Options:
        // YY - YEAR POSTED
        // MM - MONTH POSTED 
        // DD - DATE POSTED 
        // UT - USER TXNCODE
        // SQ - SEQUENCE 
        // FS - FORMATTED SEQUENCE 
        
        def txncode = ["REM", env.TXNCODE, env.ORGTXNCODE].findAll{( it )}.join("-");
        def dt = dateSvc.parseDate( remittance.dtposted, null); 
        def values = [ 
        	YY:dt.year+"", 
        	MM:dt.month.toString().padLeft(2, '0',),
        	DD:dt.day.toString().padLeft(2, '0'),
        	UT:txncode 
        ];

        def txnno = format;  
        values.keySet().each {
            txnno = txnno.replace( it, values[it] )
        }

        def series; 
        if ( seqid ) { 
        	def seq = seqid;
        	values.keySet().each {
            	seq = seq.replace( it, values[it] )
            }
            series = seqSvc.getNextSeries( seq); 
            
        } else { 
        	series = seqSvc.getNextSeries(  txnno.replace("FS", '') ); 
        }

        txnno = txnno.replace( 'SQ', series+"" );
        txnno = txnno.replace( 'FS', "$series".padLeft(5, '0')); 
        return txnno; 
    }

    @ProxyMethod 
    public void revert( params ) {
    	if ( !params.objid ) throw new Exception('objid parameter is required'); 

    	params.remittanceid = params.objid; 
    	def o = remittance_tool.findRemittance( params ); 
    	if ( o?.liquidated > 0 ) 
    		throw new Exception('This transaction has already been liquidated. Cannot revert remittance'); 

    	remittance_tool.removeFunds( params ); 
    	remittance_tool.removeAFs( params ); 
    	remittance_tool.removeCashReceipts( params ); 
    	remittance_tool.removeCreditMemoPayments( params ); 
    	remittance_tool.removeNonCashPayments( params ); 
    	remittance_tool.removeRemittance( params ); 
    } 

    @ProxyMethod
    public void approve(def o) {
    	def m = [state:'APPROVED'];
    	m.liquidatingofficer = [ objid:env.USERID, name:env.FULLNAME, title:env.JOBTITLE, signature: o.signature ]; 
    	remdb.find( [objid : o.objid] ).update( m );
    }
}