import com.rameses.annotations.*;
import com.rameses.common.*
import com.rameses.util.*;

class ElectronicPaymentOrderService  {

	@Service('CacheService')
	def cacheSvc; 

	@Service('DateService')
	def dateSvc;

	@Service('PaymentOrderService') 
	def payOrderSvc; 

	@Service('ElectronicReceiptService') 
	def receiptSvc;

	@DataContext("eor_paymentorder")
	def eor_paymentorder; 


	@ProxyMethod 
	public def findCache( key ) { 
		return cacheSvc.get( key ); 
	} 

	@ProxyMethod 
	public def create( params ) {
		if ( !params.billid ) throw new Exception('billid parameter is required.'); 

		def bill = cacheSvc.get([ key: params.billid ]); 

		def pmo = [:];
		pmo.txnid = bill.txnid; 
		pmo.controlno = bill.controlno; 
		pmo.payer = bill.payer; 
		pmo.paidby = bill.paidby;
		pmo.paidbyaddress = bill.paidbyaddress;
		pmo.particulars = bill.particulars;
		pmo.amount = bill.amount; 
		pmo.expirydate = bill.expirydate;
		pmo.refid = bill.refid;
		pmo.refno = bill.refno; 
		pmo.txntype = bill.txntype;
		pmo.info = (bill.info ? bill.info : [:]); 
		pmo = payOrderSvc.create( pmo ); 

		if ( !params.paymenttype || params.paymenttype=='CASHIER' ) {
			//do nothing 
		} else { 
			logForPaymentImpl( pmo, bill ); 
		} 

		cacheSvc.put([ key:pmo.txnid, value:pmo ]); 
		return pmo; 
	} 

	@ProxyMethod
	public def logForPayment( params ) {
		if (!params.txnid) throw new Exception('txnid parameter is required.')

		def pmo = cacheSvc.get([ key: params.txnid ]); 
		if (!pmo) throw new Exception('Payment Order cannot be loaded. Please close and repeat the transaction.')

		return logForPaymentImpl( pmo, null );  
	} 

	private def logForPaymentImpl( pmo, bill ) { 
		if (!pmo.txnid) throw new Exception('txnid parameter is required.'); 

		def eor = eor_paymentorder.find([ objid: pmo.txnid ]).first();  
		if ( !eor ) {
			eor = [ state: 'FOR_PAYMENT' ];
			eor.dtcreated = dateSvc.getServerDate();
			eor.objid = pmo.txnid;
			eor.refid = pmo.refid;
			eor.refno = pmo.refno;
			eor.paymentorder = pmo; 
			if ( bill ) {
				eor.billinfo = new com.rameses.util.Base64Cipher().encode( bill ); 
			}
			eor_paymentorder.create(eor); 
			eor.remove('billinfo');  
		} 
		return eor; 
	} 

	@ProxyMethod 
	public def logForPosting( eor ) { 
		if ( !eor.objid ) throw new Exception('objid parameter is required.'); 

		def o = eor_paymentorder.find([ objid: eor.objid ]).first(); 
		if ( !o ) throw new Exception(''+ eor.objid +' eor_paymentorder record does not exist'); 

		def rundate = dateSvc.getServerDate();
		def m = [ dtposted: rundate, state: 'FOR_POSTING' ]; 
		m.traceno = eor.refno; 
		m.tracedate = ( eor.refdate ? eor.refdate : rundate ); 
		m.traceinfo = ( eor.info ? eor.info : [:]); 
		m.traceinfo.txnrefid = eor.txnrefid;
		m.traceinfo.txnreftype = eor.txnreftype;
		m.traceinfo.particulars = eor.particulars;
		m.traceinfo.txntype = eor.txntype;
		m.traceinfo.partner = eor.partner;
		eor_paymentorder.find([ objid: eor.objid ]).update( m ); 
		o.putAll( m ); 
		return o; 
	} 

	@ProxyMethod 
	public def post( params ) {
		if ( !params.txnid ) throw new Exception('txnid parameter is required.'); 

		def o = eor_paymentorder.find([ objid: params.txnid ]).first(); 
		if ( !o ) throw new Exception(''+ eor.objid +' eor_paymentorder record does not exist'); 

		def crpeor = [ objid: o.traceno ]; 
		crpeor.refdate = o.tracedate;
		crpeor.refno = o.traceno; 
		crpeor.txnrefid = o.objid; 
		if ( o.traceinfo ) { 
			crpeor.txnreftype = o.traceinfo.txnreftype;
			crpeor.txntype = o.traceinfo.txntype;
			crpeor.partner = o.traceinfo.partner;
		} 

		def pmo = o.paymentorder; 
		if ( pmo ) {
			crpeor.amount = pmo.amount; 
			crpeor.txntype = pmo.txntypeid;
			crpeor.particulars = pmo.particulars; 
		}

		receiptSvc.createPayment( crpeor );  
		crpeor.txntype = [ objid: pmo.txntypeid ];

		def bill = findCache( pmo?.refid ); 
		pmo.items = bill.items; 
		pmo.txntype = crpeor.txntype; 

		def rct = receiptSvc.createReceipt( pmo, crpeor ); 
		eor_paymentorder.find([ objid: o.objid ]).update([ state: 'POSTED' ]); 
		return rct;  
	} 
}
