import com.rameses.annotations.*;
import com.rameses.util.*;
import com.rameses.common.*

class ElectronicReceiptService  {

	@Env 
	def env 

	@DataContext("cashreceipt")
	def cashreceipt; 

	@DataContext("cashreceiptitem")
	def cashreceiptItem; 

	@DataContext("collectiontype")
	def collectiontype; 

	@DataContext("cashreceiptpayment_eor")
	def eor; 

	@DataContext("af_control")
	def afControl; 

	@Service("DateService")
	def dateSvc;
		
	@Service("NumberService")
	def numSvc;
	
	@Service('PersistenceService')
	def persistence;
	
	@Service('CacheService')
	def cacheSvc; 

	@Service('OrgService')
	def orgSvc;

	@Service('PaymentOrderService') 
	def paymentOrderSvc;
	
	@ProxyMethod 
	public def findCache( params ) {
		if ( !params.key ) throw new Exception('key parameter is required');  

		return cacheSvc.get([ key: params.key ]);  
	}
	
	@ProxyMethod
	public def createPayment( o ) {
		o.dtposted = dateSvc.getServerDate(); 
		if (!o.refdate) o.refdate = o.dtposted 

		o = eor.create( o ); 
		return o; 
	} 

	@ProxyMethod(local=true)
	public def createReceipt( def p, def eorp ) { 
		if( !p.items ) throw new Exception("ElectronicReceiptService must have items"); 

		def svrDate = dateSvc.getServerDate(); 
		def entity = [:];
		entity.org = orgSvc.getRoot();
		entity.collector = getCollector();
		entity.putAll( getNextEORNumber() );
		entity.state = 'POSTED';
		entity.txnmode = 'ONLINE';
		entity.payer = p.payer;
		entity.paidby = p.paidby;
		entity.paidbyaddress = p.paidbyaddress;
		entity.amount = numSvc.round( p.amount );
		if(!p.receiptdate) {
			entity.receiptdate =  svrDate;
		}	
		entity.txndate = svrDate;
        entity.balancedue = 0;
        entity.cashchange = 0;
        entity.totalcredit = 0;
        entity.totalcash = 0;
        entity.totalnoncash = entity.amount;
		entity.user = [objid: 'EOR', name:'EOR'];

		def txntypeid = null; 
		if ( p.txntype instanceof Map ) {
			txntypeid = p.txntype.objid; 
		} else {
			txntypeid = p.txntype; 
		} 

		def paytype = paymentOrderSvc.findPaymentType([ objid: txntypeid ]); 
		entity.collectiontype = paytype?.collectiontype;

        cashreceipt.create( entity );
        p.items.each { m->
        	m.receiptid = entity.objid; 
        	cashreceiptItem.create( m ); 
        } 

        //update the eor payment.
		eor.find([ objid: eorp.objid ]).update([ receiptid: entity.objid ]);
		entity.paymentitems = [ eorp ]; 
		deletePaymentOrder(p);
		formatReport(entity); 
		return entity;
	} 

	@ProxyMethod(local=true)
	public def openReceipt( params ) { 
		def o = cashreceipt.find([ objid: params.objid ]).first(); 
		if ( o ) {
			o.items = cashreceiptItem.find([ receiptid: o.objid ]).list(); 

			def colltypeid = o.collectiontype?.objid; 
			def newcolltype = collectiontype.find([ objid: colltypeid ]).first(); 
			if ( newcolltype ) o.collectiontype = newcolltype; 
		} 
		return o; 
	}  


	@ProxyMethod
	public def postReceipt( crpeor, receipt, bill ) { 
		env.bill = bill; 
		return receipt; 
	}  



	def getControl( def afControlId ) {
		def ac = afControl.find( [objid: afControlId ]).first();
		if(!ac) {
			ac = [objid:afControlId];
			ac.afid = 'EOR';
			ac.startseries = 1;
			ac.endseries = 999999999;
			ac.currentseries = 1;
			ac.stubno = 1;
			ac.active = 1;
			ac.owner =  getCollector();
			ac.assignee = ac.owner;
			afControl.create(ac);
		}
		return ac;
	}

	def getCollector(){
		return [objid: 'EOR', name:'EOR', title:'EOR']
	}

	def getNextEORNumber() {
		String afControlId = 'EOR'+ dateSvc.getServerYear();
		def ac = getControl(afControlId);
		int series = ac.currentseries;
		afControl.find( [objid: afControlId] ).update( [currentseries: series + 1] );
		return [series: series, receiptno: afControlId + '-' + series, formno:'EOR', formtype:'serial', controlid: afControlId, stub: 1 ] ;
	}

	def formatReport( def p ) {
		p.payerdetails = p.paidby + "\n" + p.paidbyaddress;
		if( p.amount < 1 ) { 
			def amount = Long.parseLong( p.amount.toString().split("\\.")[1] )
			p.amountinwords = numSvc.doubleToWords( amount ).toUpperCase() + " CENTAVOS";
		} else 
			p.amountinwords = numSvc.doubleToWords( p.amount ).toUpperCase() + " PESOS ONLY";
		return p;
	}
	
	void deletePaymentOrder(p){
		def q = [:]
		q._schemaname = 'paymentorder'
		q.txnid = p.txnid 
		persistence.removeEntity(q)
	}
}
