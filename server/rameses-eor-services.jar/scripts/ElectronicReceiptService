import com.rameses.annotations.*;
import com.rameses.util.*;
import com.rameses.common.*

class ElectronicReceiptService  
{

	@Env 
	def env 

	@DataContext("cashreceipt")
	def cashreceipt; 

	@DataContext("cashreceiptitem")
	def cashreceiptItem; 

	@DataContext("af_control")
	def afControl; 

	@DataContext("cashreceiptpayment_eor")
	def eor; 

	@Service("DateService")
	def dateService;
		
	@Service("NumberService")
	def numSvc;
	
	@Service('PersistenceService')
	def persistence 
	
	@Service('CacheService')
	def cache 

	@Service('OrgService')
	def orgSvc 
	
	@ProxyMethod
	public def createPayment( o ) {
		o.dtposted = dateService.serverDate 
		if (!o.refdate) o.refdate = o.dtposted 
		o = eor.create( o );
		cache.put([key:o.objid, value:o])
		return o 
	}


	@ProxyMethod
	public def post( def p, def eorPayment ) {
		if( !p.items ) throw new Exception("ElectronicReceiptService must have items"); 

		def svrDate = dateService.serverDate;
		def entity = [:];
		entity.putAll( getNextEORNumber() );
		entity.state = 'POSTED';
		entity.txnmode = 'ONLINE';
		entity.payer = p.payer;
		entity.paidby = p.paidby;
		entity.paidbyaddress = p.paidbyaddress;
		entity.amount = numSvc.round( p.amount );
		if(!p.receiptdate) {
			entity.receiptdate =  svrDate;
		}	
		entity.txndate = svrDate;
		entity.org = orgSvc.getRoot();
		entity.collector = getCollector()
		entity.user = [objid: 'EOR', name:'EOR'];
        entity.totalcash = 0;
        entity.totalnoncash = entity.amount;
        entity.balancedue = 0;
        entity.cashchange = 0;
        entity.totalcredit = 0;
        entity.collectiontype = p.txntype.collectiontype;
        cashreceipt.create(entity);
        p.items.each { m->
        	m.receiptid = entity.objid;
        	cashreceiptItem.create(m);
        };

        //update the eor payment.
		eor.find( [ objid: eorPayment.objid ] ).update([receiptid: entity.objid] );

		entity.paymentitems = [eorPayment];	

		deletePaymentOrder(p)
		return formatReport(entity);
	}	

	def getControl( def afControlId ) {
		def ac = afControl.find( [objid: afControlId ]).first();
		if(!ac) {
			ac = [objid:afControlId];
			ac.afid = 'EOR';
			ac.startseries = 1;
			ac.endseries = 999999999;
			ac.currentseries = 1;
			ac.stubno = 1;
			ac.active = 1;
			ac.owner =  getCollector();
			ac.assignee = ac.owner;
			afControl.create(ac);
		}
		return ac;
	}

	def getCollector(){
		return [objid: 'EOR', name:'EOR', title:'EOR']
	}

	def getNextEORNumber() {
		String afControlId = 'EOR'+ dateService.getServerYear();
		def ac = getControl(afControlId);
		int series = ac.currentseries;
		afControl.find( [objid: afControlId] ).update( [currentseries: series + 1] );
		return [series: series, receiptno: afControlId + '-' + series, formno:'EOR', formtype:'serial', controlid: afControlId, stub: 1 ] ;
	}

	def formatReport( def p ) {
		p.payerdetails = p.paidby + "\n" + p.paidbyaddress;
		if( p.amount < 1 ) { 
			def amount = Long.parseLong( p.amount.toString().split("\\.")[1] )
			p.amountinwords = numSvc.doubleToWords( amount ).toUpperCase() + " CENTAVOS";
		} else 
			p.amountinwords = numSvc.doubleToWords( p.amount ).toUpperCase() + " PESOS ONLY";
		return p;
	}
	
	void deletePaymentOrder(p){
		def q = [:]
		q._schemaname = 'paymentorder'
		q.txnid = p.txnid 
		persistence.removeEntity(q)
	}
}
