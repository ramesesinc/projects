import com.rameses.annotations.*;
import java.rmi.server.UID;
import com.rameses.util.*;

import vehicle.facts.*;
import treasury.utils.*;
import treasury.facts.*;

class BillingCashReceiptService {

	@Service
	def self;

	@ProxyMethod
	public def getBillInfo( def o ) { return [:]; }

	@ProxyMethod
	public def getPostPaymentInfo( def o ) { return [:]; }

	@ProxyMethod
	public def getWorkflowTask( def o ) { return [:]; }

	@ProxyMethod
	public def getInfo( def o ) {
		if(!o.collectiontype?.handler) throw new Exception("collectiontype handler is required in CashReceiptBillingService.getInfo");
		def p = self.getBillInfo( o );
		if( p.payer && !p.payer.objid ) throw new Exception("Payer must have an objid ");
		if( !p.paidby  ) throw new Exception("Paid by is required");
		if( !p.paidbyaddress ) throw new Exception("Paid by address is required ");
		o.putAll( p );
		def bi = getItems( p );
		o.putAll( bi );
		return o;
	}

	@ProxyMethod
	public def getItems( def p ) {
		def b = self.getBillItems( p );
		if( !b.billitems )
			throw new Exception("CashReceiptBillingService error. billitems is required for " + p.collectiontype.handler );

		def billitems = b.billitems;
		p.billitems = billitems.findAll{ it.txntype==null || !it.txntype.toLowerCase().matches('discount|surcharge|interest')  };

		//if cash receipt items not specified
		if( !b.items ) {
			//summarize the billitems into cashreceipt items. For specialized grouping, the group complex field must be specified
			//in each billitem, otherwise this will be grouped by account only. The group must contain the label and remarks if any.
			def cashRctItems = [];
			def grpItems = billitems.groupBy{ [it.item, it.group] };
			grpItems.each { k,v->
				cashRctItems << [item: k[0], remarks: k[1]?.remarks, amount: NumberUtil.round(v.sum{ it.amount }) ];
			} 
			p.items = cashRctItems;
			p.items.each {
				if(!it.item?.objid) throw new Exception("item.objid is required");
				if(!it.item?.title) throw new Exception("item.title is required");
				if(!it.amount) throw new Exception("amount is required in line item");
			}
		}
		p.amount = p.items.sum{ it.amount };


		//get also the payment info. This will instruct the PostPaymentService regarding how to update the ledger
		def payInfo = billHandler.getPostPaymentInfo(  p );
		if( payInfo ) {
			if( !payInfo._schemaname  )
				throw new Exception("CashReceiptBillingService.getItems getPostPaymentInfo error _schemaname is required");
			if( !payInfo.items  )
				throw new Exception("CashReceiptBillingService.getItems getPostPaymentInfo error items is required");
			payInfo.items.each {
				if(!it.item?.objid) throw new Exception( "CashReceiptBillingService.getItems getPostPaymentInfo error. item.objid is required in each item" );\

				if(!it.reftype ) throw new Exception( "CashReceiptBillingService.getItems error. getPostPaymentInfo reftype  is required in each item" );

				//normally refid is required, however there are instances when the reference does not yet exist in ledger which needs to be created.
				//In case like this, postinrefid will be null but there must _new=true flag.
				if(!it.refid) {
					if(! (it._new == true )) {
						throw new Exception( "CashReceiptBillingService.getItems getPostPaymentInfo error. refid  is required in each item or if new must indicate a _new=true flag" );		
					}
				} 
			}
			payInfo.amount = p.amount;
			p._postpayment = payInfo;
		}

		//check if there is workflow tasks
		def taskInfo = billHandler.getWorkflowTask(  p );
		if( taskInfo ) {
			if( !taskInfo.processname ) 
				throw new Exception("CashReceiptBillingService.getItems getWorkflowTask error processname is required");
			if( !taskInfo.refid )
				throw new Exception("CashReceiptBillingService.getItems getWorkflowTask error refid is required");
			p._workflow = taskInfo;		
		}

		return p;
	}
	

}