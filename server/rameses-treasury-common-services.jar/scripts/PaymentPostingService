import com.rameses.annotations.*;

class PaymentPostingService {
	
	@DataContext(dynamic=true)
	def em;

	@PersistenceContext
	def db;

	@Service("WorkflowTaskService")
	def taskSvc;

	@Service("SingleBillingHandler")
	def billingHandler;


	@Service("SequenceService")
	def seqSvc;

	void invokeWorkflow( def pmt, def action ) {
		//check if there is workflow tasks
		def taskInfo = billingHandler.getPaymentWorkflow(  pmt );
		if( taskInfo ) {
			if( !taskInfo.processname ) 
				throw new Exception("CashReceiptBillingService.getItems getWorkflowTask error processname is required");
			if( !taskInfo.refid )
				throw new Exception("CashReceiptBillingService.getItems getWorkflowTask error refid is required");
			taskInfo.autostart = true;	
			if(action=="pay") {
				taskInfo.action = taskInfo.payaction;
			}
			else {
				taskinfo.voidaction = taskInfo.voidaction;
			}
			taskSvc.signal( taskInfo );		
		}
		return null;
	}	

	@ProxyMethod 
	public void post( def pmt ) {

		//save first the xxx_payment. 
		def emMap = [:];
		def emLookup = { name ->
			if( !emMap.containsKey(name)) {
				emMap.put( name, em.lookup( name));
			}
			return emMap.get(name);
		}
		

		//save or update the reference first
		pmt.items.each {
			if( it.txntype== "credit" ) {
				//if there is overpayment or credit items, create a new xxx_credit item
				def p = [:];
				p.parentid = pmt.parentid;
				p.rootid = pmt.rootid;
				p.refno = pmt.refno;
				p.reftype = pmt.reftype;
				p.refid = pmt.refid;
				p.refdate = pmt.refdate;
				p.item = it.item;
				p.amount = it.amount;
				p.amtpaid = 0;
				p.remarks = it.remarks;
				def reftype = pmt.collectiontype.handler+'_credit';
				def crEm = emLookup( reftype );
				def vv = crEm.create( p );
				it.refid = vv.objid;
				it.reftype = reftype;
			}
			else if( it.txntype == "creditpayment") {
				//this is to close out deduction of previous payment
				def reftype = it.reftype;
				if(!reftype) reftype = pmt.collectiontype.handler+'_credit';
				def crEm = emLookup( reftype );
				def amt = (it.amount * -1);
				crEm.find( [objid: it.refid ] ).update( [amtpaid: "{amtpaid + :amt}"], [amt: amt] );
			}
			else if(it.reftype) {
				def gb = emLookup( it.reftype  );
				//if there is a _new marker, then create this before saving
				if( !it.refid || it.refid.matches("new|create") ) {
					it.remove("refid");
					gb.create( it );	
				}
				else {
					//find first if it exists then save 
					gb.find( [objid: it.refid] ).update( [amtpaid: "{amtpaid + :amt}"], [amt: it.amount] );
				}			
			}
		}

		pmt.voided = 0;
		def pmtEm = emLookup( pmt._schemaname );
		pmt = pmtEm.create( pmt );

		invokeWorkflow( pmt, "pay" );
	}
  
	@ProxyMethod 
	public def reversePayment( def pmt ) {
		if(!pmt._schemaname ) 
			throw new Exception("PaymentPostingService.reversePayment error. _schemaname is required");
		if( !pmt.objid)
			throw new Exception("PaymentPostingService.reversePayment. Payment objid is required");

		def emMap = [:];
		def emLookup = { name ->
			if( !emMap.containsKey(name)) {
				emMap.put( name, em.lookup( name));
			}
			return emMap.get(name);
		}

		def sb = [];

		//after create post the posting references
		pmt.items.findAll{ it.reftype !=null }.each {
			def gb = emLookup( it.reftype );
			if( it.reftype.contains("credit") ) {
				//if credit amount is positive it means this is original value so make it immediately the amount
				if(it.amount > 0 ) {
					gb.find( [objid: it.refid] ).update( [amtpaid: it.amount] );
				}
				else {
					//we add this because amount is negative value
					gb.find( [objid: it.refid] ).update( [amtpaid: "{amtpaid + :amt}"], [amt: it.amount] );
				}
			}
			else {
				gb.find( [objid: it.refid] ).update( [amtpaid: "{amtpaid - :amt}"], [amt: it.amount] );
			}
		}

		def pmtEm = emLookup( pmt._schemaname );
		pmtEm.find( [ objid: pmt.objid ] ).update( [voided : 1 ] );

		invokeWorkflow( pmt, "voidpayment");
		
		return pmt;
	}

	/*
	def wf = voidHandler.getVoidPaymentWorkflow( pmt );
		if(wf) { 
			if(!wf.processname) throw new Exception("processname is required in getVoidPaymentInfo.getVoidPaymentWorkflow for " + rct.collectiontype.handler );
			if(!wf.taskid) throw new Exception("taskid is required in getVoidPaymentInfo.getVoidPaymentWorkflow for " + rct.collectiontype.handler );
			if(!wf.action) throw new Exception("action is required in getVoidPaymentInfo.getVoidPaymentWorkflow for " + rct.collectiontype.handler );
			if(!wf.refid ) throw new Exception("refid is required in getVoidPaymentInfo.getVoidPaymentWorkflow for " + rct.collectiontype.handler );

			wf.autostart = true; //flag to indicate that this must start task immediately, does not require assign to me
			pmt._workflow = wf; 
		}
	*/	


}